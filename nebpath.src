C 16 Apr 19 - SK  - Clean up for gfortran
C 15 Mar 19 - SK  - Start working on parallel computation
C 12 Mar 19 - SK  - Generate structures between the neighbouring beads at the end of calculation
C 11 Mar 19 - SK  - Add a restart option.
C 09 Mar 19 - SK  - Finish coding.  Need to check options and test jobs.
C 07 Mar 19 - SK  - Got reasonable energies and gradients at each initial bead
C 06 Mar 19 - SK  - Start adding NEB_run
C 05 Mar 19 - SK  - Debugging IDPP routines
C 04 Mar 19 - SK  - Start adding Sawada's routines
C 23 Feb 19 - SK  - Start creating NEBpath routines
C
C*MODULE NEBPATH *DECK NEBPX
C>
C>    @brief    NEBPATH main driver, Release 1
C>
C>    @details  Nudged Elastic Band (NEB) method (Release 1, April 2019)
C>              find a reaction path for specific reactant and product.
C>              Multiple transition states can be located along an NEB path.
C>
C>              PLAN: Release 2 --- Climbing NEB method to locate a transition state.
C>                                  (July 2019)
C>              PLAN: Release 3 --- String method to locate a transition state exactly.
C>                                  (December 2019)
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
c     **********************
C     Options for $NEB group
c     **********************
C     Caution: The coordinates of the reactant are given by $DATA
c              The coordinates of the product should be given by $DATAPD.
c              The atom order should be same in both reactant and product.
c              The product should be aligned as close to the reactant as possible,
c              Otherwise, some curious paths could be generated by this routine.
c              The molecular orientation is very important to obtain a reasonable
c              reaction path.               **************
c
c              Basically, molecular symmetry cannot be used.  However, if a reaction
c              path has symmetry on the whole way, you may be able to use it... ?
c
c
c             Caution: keywords can have only 6 characters.
c
C     $NEB    NBEADS    = number of beads along the NEB path (default=15)
c                         (maximum number of beads is set to MXBEADS=50)
c             untcrd    = unit for the coordinates given by the $DATAPD and $DATAVI
c                         groups; angs or bohr  (default = angs)
c
c             MAXCYC    = maximum number of cycles for geometry optimization
c                         along the path perpendicular to the reaction path.
c                         (default = 500)
c
c x           OPTTOL    = Tolerance for the gradient norm perpendicular to the
c             OPTTOL    = Tolerance for the gradient RMS perpendicular to the
c                         reaction path (unit=au/bohr, default = 0.001d+00)
c                         (0.0001d+00 is too small?)
c
c             QUCKDT    = distance displaced from each bead along the path 
c                         perpendicular to the reaction path.
c                       = (default = 0.2d+00)
c                     x = (default = 0.01d+00)  ---  too small
c                     x = (default = 0.1d+00)
c                     x = (default = 0.5d+00)   ---  quckdt*20 for IDPP is too large.
c                         (unit = bohr)
c
C             SPFORC    = force constant for a spring between two adjacent beads
c                         (unit = hartree/bohr**2, default = 0.5d+00)
c                         500 kcal/A^2 = 500*a0^2/23/27 au/bohr^2 = 0.2, so ...
c
c             VIAPNT    = a via-point structure along the reaction path
c                         The coordinates are given in the $DATAVI group.
c                         (default=.false.)
c
c             RESTRT    = Restart option.  See $BEADSX.
c                         (default = .false.)
c
c             iSTART    = Number of cycles in the previous calculation
c
c             --------- this option should not be listed in the manual...
c             Morint    = caution for molecular orientation
c                         (default=.false.)
c             MOLSYM    = say .true. if your reaction path has molecular symmetry
c                         along the whole way.  Otherwise, only "C1" can be used
c                         in the $DATA group.
c                         (default=.false.)
c             ---------
c
c             The followings are unavailable right now
c
c             TSLOCT    = locating a transition state structure
c                         (default = .false.)
c
c             OPTMZR    = method of a geometrical structure at each bead
c                         quick-min  (default)
c                         steepest descent
c                         FIRE
c
c             (more options will be added.)
c
c     $DATAPD           = the coordinates of the product
c                         atom name, atomic number, x, y, z for each atom
c             (should be given for all atoms, even if a molecular symmetry exists)
c
c     $DATAVI           = the coordinates of the via-point structure (optional)
c                         atom name, atomic number, x, y, z for each atom
c             (should be given for all atoms, even if a molecular symmetry exists)
c
c     ---------------
C     Dictionary file
c     ---------------
c     IREC = 1   Atomic coordinates
c     IREC = 2   Various energy quantities (Common /ENERGYS/)
c     IREC = 3   Gradient vector
c     IREC = 4   Hessian matrix (not use)
c     IREC = 15  Alpha orbitals
c     IREC = 19  Beta  orbitals
c
c     
c     IREC = 701 #Bead, coordinates, energy gradients, VEC at BEAD 1
c     IREC = 702 #Bead, coordinates, energy gradients, VEC at BEAD 2
c     IREC = 703 #Bead, coordinates, energy gradients, VEC at BEAD 3
c     IREC = 704 #Bead, coordinates, energy gradients, VEC at BEAD 4
C
c     IREC = 715 #Bead, coordinates, energy gradients, VEC at BEAD 15 (default)
C
c     IREC = 730 #Bead, coordinates, energy gradients, VEC at BEAD 30 (if necessary)
c                NBEADS < 31 ?
c
C>
      SUBROUTINE NEBPX
C
      USE MX_LIMITS,ONLY:MXFRG,MXPT,MXFGPT,MXDFG,MXDPPT,mxatm,mxao
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      LOGICAL  xoption, CVGED, ABEL
C
      PARAMETER (MXA3=3*MXATM)
      PARAMETER (MXNCF=6*MXFRG)
      PARAMETER (MXBEADS=50)
C
      PARAMETER (NNAM=14)
      DIMENSION  QNAM(NNAM),KQNAM(NNAM)
C
      Dimension    IX(MXATM*MXBEADS)
c
      Dimension    PROCRD(MXATM*4), VIACRD(MXATM*4)
      Logical      VIAPNT, TSLOCT, morint, molsym, Restrt
c
c     Character*8  UNTCRD, OPTMZR, GROUP, EXETYP, CHECK, RUNTYP
c
c.SK@20190315 ----------------
      LOGICAL GOPARR,DSKWRK,MASWRK,DEBUG
c     LOGICAL GOPARR,DSKWRK,MASWRK,ISGDDI,PAROUT,INITGDDI,wasgddi,MLGDDI
c.SK@20190315 ----------------
C             
      COMMON /FMCOM / X(1)
c
c     COMMON /FUNCT / E,EG(MXA3)
c     COMMON /FUNCT / ENERGY,EGRAD(3,MXATM)
      COMMON /FUNCT / ENERGY,EGRAD(MXA3)
c
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MASSES/ ZMASS(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /SYMMOL/ GROUP,COMPLEX,IGROUP,NAXIS,ILABMO,ABEL
c
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (ONE=1.0D+00)
      PARAMETER (two=2.0d+00)
      PARAMETER (TOANGS=0.52917724924D+00)
      PARAMETER (TOKCAL=627.509469D+00)
C
      DATA SNEB/8HNEB     /
      DATA QNAM/8HNBEADS  ,8HMAXCYC  ,8HUNTCRD  ,8HQUCKDT  ,
     *          8HOPTTOL  ,8HCRDTOL  ,8HSPFORC  ,8HRESTRT  ,
     *          8HMOLSYM  ,8HMORINT  ,8HVIAPNT  ,8HOPTMZR  ,
     *          8HTSLOCT  ,8HISTART  /
c     Caution: only 6 characters can be used.
c
      DATA KQNAM/1,1,5,3, 3,3,3,0, 0,0,0,5, 0,1/
c                1 2 3 4  5 6 7 8  9 0 1 2  3 4
c
C              0=logical        (e.g. DIRSCF)
C              1=integer        (e.g. MULT)
C              3=floating point (e.g. OPTTOL)
C              5=characters     (e.g. SCFTYP)
c
      DATA CHECK     /8HCHECK   /
      data untang    /8HANGS    /,   untbhr/8HBOHR    /
      DATA NEBPATH   /8HNEBPATH /, QUICKMIN/8HQUICKMIN/
      DATA UNDEFINED /8H        /,ANGSTROMS/8HANGS    /
      DATA C1        /8HC1      /
      DATA GRADIENT  /8HGRADIENT/
C
C     ----- Nudged Elastic Band pathfinder -----
C
      IF(MASWRK) WRITE(IW,9000)
 9000 FORMAT(/,10X,30(1H-)/10X,'Nudged Elastic Band Pathfinder'/
     *         10X,30(1H-),
     */,10x,'implemented in March 2019',
     */,10x,' by Nozomi Sawada, Mamoru Haruta,',
     *      ' Toshio Asada, and Shiro Koseki,',
     */,10x,'Osaka Prefecture University, Japan.',
     */,10x,'Reference: Chem Phys Lett in progress.')
C
      debug = .false.
      if(EXETYP.eq.NEBPATH) debug=.true.
c
c     DO 10 I=1,NNAM
c        IF(KQNAM(I).EQ.-3) KQNAM(I) = (NAT*4)*10 +3
c  10 CONTINUE
c
      N4 = 4 * NAT
c          iat,x,y,z
c
c     ---------------------------------------
c     Defaults of options...
c
      NBEADS = 15             ! MXBEADS = 50
c
      UNTCRD = untang
c
      maxcyc   = 500
c
c     Ftol   = 0.050d+00      ! this is not an input option...
c     Ftol   = 0.030d+00      ! this is not an input option...
      Ftol   = 0.010d+00      ! this is not an input option...
c
c     SPFORC = 500.0d+00 kcal/mol/A^2
c     SPFORC = 0.2d+00   ! au/bohr^2   --- too small?
      SPFORC = 0.5d+00
c
      quckdt  = 0.01d+00
      quckdt  = 0.1d+00
      quckdt  = 0.2d+00
cx    quckdt  = 0.5d+00
c     Caution: this is for NEB_run.
c              quckdt*5  will be used for IDPP.
c            x quckdt*10 will be used for IDPP.
c            x quckdt*20 will be used for IDPP.
c     ------------------------------------------
c
c     opttol = 0.00010d+00    ! [au/bohr] = too small?
      opttol = 0.0010d+00
c
      crdtol = 20.0d+00       ! a largest distance...?
c
      VIAPNT = .false.
c
      Morint = .false.
      molsym = .false.
      Restrt = .false.
      iSTART = 0
c
      TSLOCT = .false.
c     ------------------------------------------
c
      PROCRD(1:n4) = zero
      VIACRD(1:n4) = zero
c
      OPTMZR = QUICKMIN
c
c     ------------------------------------------
C
C           READ NAMELIST $NEB
C
      JRET = 0
      CALL NAMEIO(IR,JRET,SNEB,NNAM,QNAM,KQNAM,
     *            NBEADS, maxcyc, UNTCRD, quckdt,
     *            OPTTOL, crdtol, SPFORC, Restrt,
     *            MOLSYM, Morint, VIAPNT, OPTMZR, TSLOCT,
     *            ISTART,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,
     *   0,0,0,0,0,   0,0,0,0,0,   0,0,0,0,0,0)
c
      IF (JRET.GT.1) THEN
         IF (MASWRK) WRITE (IW,9002)
         CALL ABRT
      END IF
      call DDI_sync(32001)
 9002 FORMAT(1X,'NAMELIST $NEB SYNTAX ERROR FOUND.')
c
c     ------------------------------------------
c
c     Check the input options...
      if(NBEADS.eq.0) NBEADS=15
      if(maxcyc.eq.0) maxcyc=500
      if(UNTCRD.eq.UNDEFINED) UNTCRD=ANGSTROMS
      if(SPFORC.eq.zero) SPFORC=0.5d+00
      if(quckdt.eq.zero) quckdt=0.2d+00
      if(OPTTOL.eq.zero) opttol = 0.0010d+00
      if(crdtol.eq.zero) crdtol = 20.0d+00     ! a largest distance...?
c
c     ------------------------------------------
c
c     Print out options and coordinates...
      IF(MASWRK)
     *   write(iw,9010) NBEADS,SPFORC,OPTMZR,VIAPNT,TSLOCT,
     *   UNTCRD,maxcyc,quckdt,crdtol,OPTTOL,Morint,molsym,
     *   Restrt,istart,goparr
      call DDI_sync(32002)
 9010 FORMAT(/,5X,'$NEB OPTIONS',/,5X,'------------',
     * /,' Number of beads                        (NBEADS) = ',i5,
     * /,' Spring force constant                  (SPFORC) = ',f10.5,
     *   ' hartree/bohr',
     * /,' Optimizer                              (OPTMZR) = ',a8,
     * /,' Via-point structure                    (VIAPNT) = ',L1,
     * /,' Transition-state search                (TALOCT) = ',L1,
     * /,' Unit for coordinates                   (UNTCRD) = ',a8,
     * /,' Maximum cycle number                   (MAXCYC) = ',i8,
     * /,' Distance multiplier for quick-min      (QUCKDT) = ',f10.5,
     * /,' Tolerance for distances (???)          (CRDTOL) = ',f10.5,
     * /,' Tolerance for geometrical optimization (OPTTOL) = ',f10.5,
     * /,' Caution for molecular orientation      (MORINT) = ',L1,
     * /,' Caution for molecular symmetry         (MOLSYM) = ',L1,
     * /,' Restart option                         (RESTRT) = ',L1,
     * /,' Number of the cycles                   (ISTART) = ',i8,
     * /,' Parallel computation                   (GOPARR) = ',L1,
     * //,'Coordinates of the reactant (BOHR)...')
c
      if(maswrk) then
         I0=0
         DO I=1,NAT
c           WRITE(IW,9020) ANAM(I),BNAM(I),ZMASS(I),
c    *           (C(j,i),j=1,3),Zan(i),Ian(i)
            WRITE(IW,9021) ANAM(I),BNAM(I),zan(I),
     *           (C(j,i),j=1,3),Zmass(i),Ian(i)
            I0=I0+3
            enddo
c
         if(GROUP.ne.C1) then
            if(.not.molsym) then
               if(maswrk) write(iw,9014)
               call abrt
               endif
            endif
c
         call NEBcoord(ir,iw,' $DATAPD',nat,procrd,maswrk,debug)
c                             12345678
c
         WRITE(IW,9022)
         I0=0
         DO I=1,NAT
            if(UNTCRD.eq.ANGSTROMS) then
               do j=2,4
                  PROCRD(i0+j)= PROCRD(i0+j)/TOANGS
                  enddo
               endif
c           WRITE(IW,9024) ANAM(I),BNAM(I),ZMASS(I),
c    *           (PROCRD(i0+j),j=1,4)
            WRITE(IW,9025) ANAM(I),BNAM(I),
     *           (PROCRD(i0+j),j=1,4),Zmass(i)
            I0=I0+4
            enddo
c
         if(VIAPNT) then
            call NEBcoord(ir,iw,' $DATAVI',nat,viacrd,maswrk,debug)
c                             12345678
            WRITE(IW,9026)
            I0=0
            DO I=1,NAT
               if(UNTCRD.eq.ANGSTROMS) then
                  do j=2,4
                     VIACRD(i0+j)= VIACRD(i0+j)/TOANGS
                     enddo
                  endif
c              WRITE(IW,9024) ANAM(I),BNAM(I),ZMASS(I),
c    *              (VIACRD(i0+j),j=1,4)
               WRITE(IW,9025) ANAM(I),BNAM(I),
     *              (VIACRD(i0+j),j=1,4),ZMASS(I)
               I0=I0+4
               enddo
            endif
         endif
      call DDI_sync(32006)
      if(GOPARR) then
         call DDI_BCAST(320050,'F',PROCRD,n4,0)
         call DDI_BCAST(320051,'F',VIACRD,n4,0)
         endif
 9014 FORMAT(//,57('*'),/,57('*'),
     */,'**                                                     **',
     */,'** Caution: if your reaction path has molecular        **',
     */,'** symmetry on the whole way, you can used molecular   **',
     */,'** symmetry.  Then, you have to re-submit your job     **',
     */,'** with MOLSYM = .true. in the $NEB group.             **',
     */,'**                                                     **',
     */,57('*'),/,57('*'),/)
 9020 FORMAT(5x,a8,a2,1x,F10.4,3F18.10,f5.1,i5)
 9021 FORMAT(1x,a8,a2,1x,F5.1,3F18.10,f15.6,i5)
 9022 FORMAT(/,'Coordinates of the product (BOHR)...')
 9024 FORMAT(5x,a8,a2,1x,F10.4,f5.1,3F18.10)
 9025 FORMAT(1x,a8,a2,1x,F5.1,3F18.10,f15.6)
 9026 FORMAT(/,'Coordinates of the via-point structure (BOHR)...')
c
c     Examine atom order...
c        Reactant and Product
      i0 = 0
      icnt = 0
      IF(MASWRK) write(iw,9040)
      do i=1,nat
         if(procrd(i0+1).ne.zan(i)) then
            icnt = icnt+1
            IF(MASWRK) write(iw,9042) i,zan(i),procrd(i0+1)
            endif
         i0 = i0+4
         enddo
      IF(MASWRK) write(iw,9045) icnt
      call DDI_sync(32007)
c
c.MWS[20190316 ---------------------------------------------
c     call ddi_nnode(nnode,mynode)
c     write(iw,'(a,2i15)') 'Debug: nnode, mynode=',nnode,mynode
c     CALL DDI_NPROC(DDI_NP,DDI_ME)
c     write(iw,'(a,2i5)') 'Debug: DDI_NP =',DDI_NP,DDI_ME
c
c     CALL DDI_SMP_NPROC(SMP_NP,SMP_ME)
c     write(iw,'(a,2i5)') 'Debug: SMP_NP,SMP_ME=',SMP_NP,SMP_ME
C
c     CALL DDI_SMP_SYNC()
c     call DDI_sync(32008)
c
c     if(debug) then
c        if(maswrk) write(iw,*) 'I have reached NEBpath-3-1'
c        call flshbf(iw)
c        call ddi_sync(15002)
c        if(maswrk) write(iw,*) 'all processes reached NEBpath-3-1'
c        call flshbf(iw)
c        MLGDDI
c        NGLEVL
c        CALL DDI_LEVEL(IMPLEMENTATION)
cx       CALL DDI_MEMORY(MEMORY,MEMDDIX,EXETYP)
c        if(maswrk) then
c           write(iw,'(a,i5)')  'IMPLEMENTATION =',IMPLEMENTATION
cx          write(iw,'(a,i15)') 'MEMORY  =',MEMORY
cx          write(iw,'(a,i15)') 'MEMDDIX =',MEMDDIX
c           endif
c        endif
c     call flshbf(iw)
c     call flshbf(ip)
c     call flshbf(is)
c     call flshbf(IPTRAJ)
c     call flshbf(idaf)
c     call DDI_sync(32009)
c.MWS[20190316 ---------------------------------------------
c
c
      IF(MASWRK) write(iw,9045) icnt
      if(icnt.gt.0) call abrt
      call flshbf(iw)
cx    if(icnt.gt.0) then
cx       IF(MASWRK) write(iw,9044) icnt
cx       call abrt
cx       else
cx       IF(MASWRK) write(iw,9046) icnt
cx       endif
      call DDI_sync(32010)
 9040 FORMAT(/,'* Examine atom order of',
     *         ' the reactant and product...')
 9042 FORMAT('Error of atom order   ---',i5,2f5.1)
 9044 FORMAT('Error: atom orders are different... icnt=',i5)
 9045 FORMAT('Caution: the number of different atom orders is',i5,
     *       ' (icnt).')
 9046 FORMAT('The atom orders are fine...         icnt=',i5)
 9050 FORMAT(/,'* Examine atom order of',
     *         ' the reactant and via-point...')
c
c     Examine atom order...
c        Reactant and Via-point structure, if necessary
      if(VIAPNT) then
         i0 = 0
         icnt = 0
         IF(MASWRK) write(iw,9050)
         do i=1,nat
            if(procrd(i0+1).ne.zan(i)) then
               icnt = icnt+1
               IF(MASWRK) write(iw,9042) i,zan(i),viacrd(i0+1)
               endif
            i0 = i0+4
            enddo
         if(icnt.gt.0) call abrt
         endif
      call DDI_sync(32011)
c
c     NAT = number of atoms
      n3 = nat*3
c     ICH = molecular charge
c     MUL = spin multiplicity
c     NUM = number of CARTESIAN GAUSSIAN BASIS FUNCTIONS
c     NE  = number of electrons
c     NA  = number of alpha electrons
c     NB  = number of beta electrons
c     ZAN = nuclear charges of atoms
c     C   = coordinates of atoms
c     IAN = atomic numbers of atoms
c     if(maswrk.and.debug) write(iw,'(a,3i5)') 'NAT,NUM,NE =',nat,num,ne
c
      CALL VALFM(LOADFM)
      LBEADS  = LOADFM  + 1
      LCWORK  = LBEADS  + 3*NAT*NBEADS
      LVWORK  = LCWORK  + 3*NAT
      LC1WORK = LVWORK  + 3*NAT
      LC2WORK = LC1WORK + 3*NAT
      LD1WORK = LC2WORK + 3*NAT
      LD2WORK = LD1WORK + NAT*NAT
      LENGY   = LD2WORK + NAT*NAT
      LGRAD   = LENGY   + NBEADS
      LSFORC  = LGRAD   + NBEADS
      LDSTNT  = LSFORC  + NBEADS
      LVELOC  = LDSTNT  + NBEADS
      LBFORC  = LVELOC  + 3*NAT*NBEADS
      LBDIST  = LBFORC  + 3*NAT*NBEADS
      LTAU1   = LBDIST  + NAT*NAT*NBEADS
      LTAU2   = LTAU1   + 3*NAT
      LSTOREI = LTAU2   + 3*NAT
      LSTORE  = LSTOREI + NBEADS
      LFTrms  = LSTORE  + 3*NAT +3*NAT +NUM*NUM*2
      LFTmax  = LFTrms  + NBEADS
      LASTM   = LFTmax  + maxcyc
c                         Coord  Grad   VEC
c     IREC = 701 #Bead, coordinates, energy, VEC(a&b) at BEAD 1
c
      NEED   = LASTM - LOADFM - 1
      CALL GETFM(NEED)
      call DDI_sync(32012)
c
c     X(LBEADS)  = Coordinates for all beads                 (3*NAT*NBEADS)
c     X(LCWORK)  = Work area of coordinates                  (3*NAT)
c     X(LVWORK)  = Work area of coordinates                  (3*NAT)
c     X(LC1WORK) = Work area of coordinates for rotation     (3*NAT)
c     X(LC2WORK) = Work area of coordinates for rotation     (3*NAT)
c     X(LD1WORK) = Work area of distance matrix for rotation (NAT*NAT)
c     X(LD2WORK) = Work area of distance matrix for rotation (NAT*NAT)
c     X(LENGY)   = Total energy at each bead                 (NBEADS)
c     X(LGRAD)   = RMS gradient at each bead                 (NBEADS)
c     X(LSFORC)  = Spring force constant                     (NBEADS)
c     X(LDSTNT)  = distance between the beads                (NBEADS)
c     X(LVELOC)  = velocity at each bead                     (3*NAT*NBEADS)
c     X(LBFORC)  = force at each bead                        (3*NAT*NBEADS)
c     X(LBDIST)  = distance matrix at each bead              (NAT*NAT*NBEADS)
c     X(LTAU1)   = work area in IDPP                         (3*NAT)
c     X(LTAU2)   = work area in IDPP                         (3*NAT)
c     X(LSTOREI) = Record number of the dictionary file      (NBEADS)
c     X(LSTORE)  = work area for Coord, Grad, and VEC        (3*NAT +3*NAT +NUM*NUM*2)
c     IREC = 701 #Bead, coordinates, energy, VEC(a&b) at BEAD 1
c     X(LFTrms)  = gradient RMS at each bead                 (NBEADS)
c     X(LFTmax)  = maximum of perpendicular gradient         (maxcyc)
c
c
      if(maswrk.and.debug)
     *   write(iw,9060) LOADFM,
     *      LBEADS,(LCWORK-LBEADS),   LCWORK,(LVWORK-LCWORK),
     *      LVWORK,(LC1WORK-LVWORK),  LC1WORK,(LC2WORK-LC1WORK),
     *      LC2WORK,(LD1WORK-LC2WORK),LD1WORK,(LD2WORK-LD1WORK),
     *      LD2WORK,(LENGY-LD2WORK),  LENGY,(LGRAD-LENGY),
     *      LGRAD,(LSFORC-LGRAD),     LSFORC,(LDSTNT-LSFORC),
     *      LDSTNT,(LVELOC-LDSTNT),   LVELOC,(LBFORC-LVELOC),
     *      LBFORC,(LBDIST-LBFORC),   LBDIST,(LTAU1-LBDIST),
     *      LTAU1,(LTAU2-LTAU1),      LTAU2,(LSTOREI-LTAU2),
     *      LSTOREI,(LSTORE-LSTOREI), LSTORE,(LFTrms-LSTORE),
     *      LFTrms,(LFTmax-LFTrms),   LFTmax,(LASTM-LFTmax),
     *      LASTM
      call DDI_sync(32013)
 9060 format(/,'*** Debug: memory allocation...',5x,'LOADFM=',i15,
     */,5x,'LBEADS  =',i15,i8,'   LCWORK  =',i15,i8,
     */,5x,'LVWORK  =',i15,i8,'   LC1WORK =',i15,i8,
     */,5x,'LC2WORK =',i15,i8,'   LD1WORK =',i15,i8,
     */,5x,'LD2WORK =',i15,i8,'   LENGY   =',i15,i8,
     */,5x,'LGRAD   =',i15,i8,'   LSFORC  =',i15,i8,
     */,5x,'LDSTNT  =',i15,i8,'   LVELOC  =',i15,i8,
     */,5x,'LBFORC  =',i15,i8,'   LBDIST  =',i15,i8,
     */,5x,'LTAU1   =',i15,i8,'   LTAU2   =',i15,i8,
     */,5x,'LSTOREI =',i15,i8,'   LSTORE  =',i15,i8,
     */,5x,'LFTrms  =',i15,i8,'   LFTmax  =',i15,i8,
     */,5x,'LASTM   =',i15)
c
c     ---------------------------
c     Clear array...
      if(maswrk.and.debug)
     *   write(iw,'(a)') 'Debug: clear the arrays; ',
     *                   'X(LBEADS), X(LVELOC), and X(LFTmax)...'
      call vclr(X(LBEADS),1,NEED)
      call vclr(X(LVELOC),1,3*nat*NBEADS)
      call vclr(X(LFTmax),1,maxcyc)
      call DDI_sync(32014)
c
c     ---------------------------
c
c     Open a trajectory file...
      IPTRAJ=4
      CALL SEQOPN(IPTRAJ,'TRAJECT','NEW',.FALSE.,'FORMATTED')
      call DDI_sync(32015)
c
c     ----------------------------------------
c     Restart...   need array...
c     RESTRT   = Restart option.  See $BEADSX.
      if(Restrt) then
         if(maswrk) then
            write(iw,9062)
            call NEBrestart(ir,iw,nat,zan,nbeads,
     *           X(LBEADS),X(LENGY),X(LGRAD),
     *           X(LVELOC),maswrk,debug)
            endif
         call DDI_sync(32016)
         if(GOPARR) then
            call DDI_BCAST(320150,'F',zan,nat,0)
            call DDI_BCAST(320151,'F',X(LBEADS),n3*nbeads,0)
            call DDI_BCAST(320152,'F',X(LENGY),nbeads,0)
            call DDI_BCAST(320153,'F',X(LGRAD),nbeads,0)
            call DDI_BCAST(320154,'F',X(LVELOC),n3*nbeads,0)
            endif
         go to 500
         endif
 9062 format(//,'*** Read the current coordinates, energy,',
     * ' and velocity at each bead ***',/)
c     ----------------------------------------
c
c     BEADS #1      = reactant
c*    call DCOPY(n3,c,x(LCWORK),1)
      i0 = LBEADS
      do i=1,nat
         do j=1,3
            x(i0) = c(j,i)
            i0 = i0+1
            enddo
         enddo
c
c     BEADS #NBEADS = product
      i0 = LBEADS + NAT*3*(NBEADS-1)
      j0 = 0
      do i=1,nat
         j0 = j0+1
         do j=1,3
            j0 = j0+1
            x(i0) = procrd(j0)
            i0 = i0+1
            enddo
         enddo
c
c     BEADS #NBEADS/2+1 = via-point
      if(VIAPNT) then
         i0 = LBEADS + NAT*3*int(NBEADS/2)
         j0 = 0
         do i=1,nat
            j0 = j0+1
            do j=1,3
               j0 = j0+1
               x(i0) = viacrd(j0)
               i0 = i0+1
               enddo
            enddo
         endif
      call DDI_sync(32017)
c
c     Move the reactant to the center of mass
      i0 = LBEADS
      if(MASWRK) write(iw,9080) i0
      call nebcom(iw,nat,anam,bnam,ZMASS,x(i0),MASWRK,debug)
      if(debug) call nebc3d(iw,0,nat,ian,x(i0),TOANGS,MASWRK)
      call DDI_sync(32018)
c
c     Move the product to the center of mass
      i0 = LBEADS +NAT*3*(NBEADS-1)
      if(MASWRK.and.debug) write(iw,9080) i0
      call nebcom(iw,nat,anam,bnam,ZMASS,x(i0),MASWRK,debug)
      if(debug) call nebc3d(iw,0,nat,ian,x(i0),TOANGS,MASWRK)
      call DDI_sync(32019)
c
c     Move the via point to the center of mass
      if(VIAPNT) then
         i0 = LBEADS +NAT*3*(NBEADS/2)
         if(MASWRK.and.debug) write(iw,9080) i0
         call nebcom(iw,nat,anam,bnam,ZMASS,x(i0),MASWRK,debug)
         if(debug) call nebc3d(iw,0,nat,ian,x(i0),TOANGS,MASWRK)
         call DDI_sync(32020)
         endif
 9080 format(/,'******** Memory pointer =',i15,
     *       /,'Move to the center of mass...')
c
c     Examine the displacement of each atom...
c        Reactant and Product
      i0 = LBEADS
      i1 = LBEADS +NAT*3*(NBEADS-1)
      call nebdchk(iw,nat,anam,bnam,Zmass,x(i0),x(i1),crdtol,MASWRK)
      call DDI_sync(32021)
c
c     Examine the displacement of each atom...
c        Reactant and Via-point
      if(VIAPNT) then
         i0 = LBEADS
         i2 = LBEADS +NAT*3*(NBEADS/2)
         call nebdchk(iw,nat,anam,bnam,Zmass,x(i0),x(i2),crdtol,MASWRK)
         call DDI_sync(32022)
         endif
c
c     Debug: print out Chem3D input (both the reactant and product)
      if(nat.gt.(mxatm/2)) then
         if(maswrk) write(iw,*) 'Error in NEBpath: nat*2 > MXATM'
         call abrt
         endif
      ij = LC1WORK
      i0 = LBEADS
      i1 = LBEADS +NAT*3*(NBEADS-1)
      do i=1,nat
         ian(nat+i) = ian(i)
         do j=1,3
            X(ij) = X(i0)
            i0 = i0 +1
            ij = ij +1
            enddo
         enddo
      do i=1,nat
         do j=1,3
            X(ij) = X(i1)
            i1 = i1 +1
            ij = ij +1
            enddo
         enddo
      if(debug) call nebc3d(iw,0,nat*2,ian,x(LC1WORK),TOANGS,MASWRK)
      call DDI_sync(32023)
c
c
c     -----------------------------------------------------------------
c     Rotation of the product molecule around COM...
      if(.not.VIAPNT) then
         i0 = LBEADS
         i1 = LBEADS +NAT*3*(NBEADS-1)
         call NEBanglr(iw,nat,anam,bnam,ian,Zmass,X(i0),X(i1),crdtol,
     *                 X(LC1WORK),X(LC2WORK),X(LD1WORK),X(LD2WORK),
     *                 toangs,MASWRK,debug)
c     -----------------------------------------------------------------
c
         else
         i0 = LBEADS
         i1 = LBEADS +NAT*3*(NBEADS/2)
         i2 = LBEADS +NAT*3*(NBEADS-1)
         call NEBanglr(iw,nat,anam,bnam,ian,Zmass,X(i0),X(i1),crdtol,
     *                 X(LC1WORK),X(LC2WORK),X(LD1WORK),X(LD2WORK),
     *                 toangs,MASWRK,debug)
         call NEBanglr(iw,nat,anam,bnam,ian,Zmass,X(i1),X(i2),crdtol,
     *                 X(LC1WORK),X(LC2WORK),X(LD1WORK),X(LD2WORK),
     *                 toangs,MASWRK,debug)
         endif
      call DDI_sync(32024)
c     -----------------------------------------------------------------
c
c     ---------------------------------------
c     Generate the coordinates at each bead.
c     ---------------------------------------
      if(.not.VIAPNT) then
         call NEB_linear_interp(nat*3,nbeads,X(LBEADS))
c
         else
c
c        reactant - via-point
         i1 = LBEADS +NAT*3*(NBEADS/2)
         nbx = nbeads/2 +1
         nby = nbeads - nbx +1
         if(maswrk.and.debug) write(iw,*)
     *                 'Debug: i0,i1,nbx,nby=',i0,i1,nbx,nby
c
         call NEB_linear_interp(nat*3,nbx,X(LBEADS))
c
c        via-point - product
         call NEB_linear_interp(nat*3,nby,X(i1))
         endif
      call DDI_sync(32025)
c
c     Examine the displacement of each atom...
c        Reactant and Product
      i1 = LBEADS -1
      do i=1,nbeads
         i0 = i1 +1
         i1 = i1 +NAT*3
         if(maswrk) write(iw,9100) i,i0,i1
         call nebdchk(iw,nat,anam,bnam,Zmass,x(i0),x(i1),crdtol,MASWRK)
         enddo
      call DDI_sync(32026)
 9100 format(/,'#Bead =',i3,'   pointers =',3i15)
c
c     Debug: print out Chem3D input
      if(debug) write(iw,*) 'Debug: before IDPP...'
      i0 = LBEADS-1
      do n=1,nbeads
         if(debug) call nebc3d(iw,n,nat,ian,x(i0+1),TOANGS,MASWRK)
         call nebc3d(IPTRAJ,n,nat,ian,x(i0+1),TOANGS,MASWRK)
         do i=1,nat
            if(maswrk.and.debug)
     *         WRITE(IW,9021) ANAM(I),BNAM(I),
     *                        (x(i0+j),j=1,3),ZMASS(I)
c    *         WRITE(IW,9020) ANAM(I),BNAM(I),ZMASS(I),
c    *                        (x(i0+j),j=1,3)
            i0 = i0+3         ! important...
            enddo
         enddo
      if(.not.Morint) then
c.SK@20190412
         call NEBtrajectory(iw,nat,anam,bnam,zan,
     *              nbeads,X(LBEADS),X(LENGY),X(LGRAD),
     *           X(LVELOC),icycle,maswrk,debug)
         call NEBtrajectory(iptraj,nat,anam,bnam,zan,
     *              nbeads,X(LBEADS),X(LENGY),X(LGRAD),
     *           X(LVELOC),icycle,maswrk,debug)
         if(maswrk) write(iw,9112)
         CALL FLSHBF(IPTRAJ)
         call abrt
         endif
      call DDI_sync(32027)
 9112 FORMAT(//,57('*'),/,57('*'),
     */,'**                                                     **',
     */,'** Caution: did you examine the molecular orientations **',
     */,'** of the reactant and product?  Your coordinates of   **',
     */,'** the reactant and product have to be satisfied with  **',
     */,'** the following conditions.  Otherwise, the generation**',
     */,'** of a realistic path will be failed.                 **',
     */,'**                                                     **',
     */,'** 1. the atom order should be same.                   **',
     */,'** 2. the product should be alined as closer to the    **',
     */,'**    reactant as possible, even though the program    **',
     */,'**    will make the reactant and the product moved to  **',
     */,'**    the center of mass, respectively, and will erase **',
     */,'**    the angular momentum caused by the geometrical   **',
     */,'**    displacement.                                    **',
     */,'** 3. Please check the orientation of your molecule    **',
     */,'**    by using chem3d input printed out into *.trj.    **',
     */,'**                                                     **',
     */,'** If the above conditions are satisfied, add the      **',
     */,'** option "MORINT=.true." and re-submit your job.      **',
     */,'**                                    (SK, 2019/02/28) **',
     */,'**                                                     **',
     */,57('*'),/,57('*'),/)
c
c
c     ------------------
c     IDPP interpolation
c     ------------------
      call NEB_idpp_interp(iw,nat,nbeads,X(LBEADS),X(LVELOC),
     *         X(LENGY),X(LBFORC), IAN,Zmass,crdtol, toangs,
     *         X(LVWORK),X(LTAU1),X(LTAU2),
     *         X(LC1WORK),X(LC2WORK),X(LD1WORK),X(LD2WORK),
     *         X(LBDIST), maxcyc, quckdt*5.0d+00,
     *         SPFORC, Ftol, maswrk,debug)
c---
c    *         X(LBDIST), maxcyc, quckdt*10.0d+00,
c    *         X(LBDIST), maxcyc, quckdt*20.0d+00,
c                                   ****************
      call DDI_sync(32028)
c---
c     x         = X(LBEADS)  = Coordinates for all beads                 (3*NAT*NBEADS)
c     velo      = X(LVELOC)  = velocity at each bead                     (3*NAT*NBEADS)
c     v         = X(LENGY)   = Total energy at each bead                 (NBEADS)
c     f         = X(LBFORC)  = force at each bead                        (3*NAT*NBEADS)
c     tau       = X(LVWORK)  = Work area of coordinates                  (3*NAT)
c     tau_plis  = X(LTAU1)   = work area in IDPP                         (3*NAT)
c     tau_minus = X(LTAU2)   = work area in IDPP                         (3*NAT)
c     F_T       = X(LC1WORK) = Work area of coordinates for rotation     (3*NAT)
c     Fs_pa     = X(LC2WORK) = Work area of coordinates for rotation     (3*NAT)
c     dc        = X(LD1WORK) = Work area of distance matrix for rotation (NAT*NAT)
c     dd        = X(LD2WORK) = Work area of distance matrix for rotation (NAT*NAT)
c     di        = X(LBDIST)  = distance matrix at each bead              (NAT*NAT*NBEADS)
c
c     X(LCWORK)  = Work area of coordinates                  (3*NAT)
c     X(LGRAD)   = RMS gradient at each bead                 (NBEADS)
c     X(LSFORC)  = Spring force constant                     (NBEADS)
c     X(LDSTNT)  = distance between the beads                (NBEADS)
c
c     Debug: print out Chem3D input
 9200 format(/,'#BEAD = ',i5)
      IF(MASWRK.and.debug) then
         write(iw,*) 'Debug: after IDPP...'
         i0 = LBEADS-1
         do n=1,nbeads
c           if(maswrk) write(iw,9200) n
            call nebc3d(iw,n,nat,ian,x(i0+1),TOANGS,MASWRK)
            do i=1,nat
               WRITE(IW,9021) ANAM(I),BNAM(I),
     *              (x(i0+j),j=1,3),ZMASS(I)
c              WRITE(IW,9020) ANAM(I),BNAM(I),ZMASS(I),
c    *              (x(i0+j),j=1,3)
               i0 = i0+3
               enddo
            enddo
         endif
      call DDI_sync(32029)
c
      if(exetyp.eq.check) go to 600
c
  500 continue
c
c.SK@20190314,321...
      RUNTYP = GRADIENT
      call DDI_sync(320131)
c     -------------------
c
c     ------------------------------------------------------------
c     Energies and gradients at the beads obtained by IDPP routine...
      if(maswrk) write(iw,*) 'Debug: call NEB_run1...'
      call NEB_run1(iw,n3, num, nbeads, X(LBEADS),
     *            X(LENGY), X(LGRAD),X(LBFORC),X(LSTOREI),X(LSTORE),
     *            crdtol,toangs,restrt,maswrk,debug)
      call DDI_sync(32030)
c
c     X(LSTOREI) = Record number of the dictionary file      (NBEADS)
c     X(LSTORE)  = work area for Coord, Grad, and VEC        (3*NAT +3*NAT +NUM*NUM*2)
c
      call vclr(X(LFTrms),1,nbeads)
      call DDI_sync(32031)
c
c     -----------------------------------------------
c     !-- NEB path optimization
      icycle = 1
      IF(MASWRK) write(iw,*) 'Debug: NEB_run icycle=',(istart+icycle)
c
c     iswitch = 0   --- qdt = quckdt*two
c     iswitch = 1   --- qdt = quckdt
c     iswitch = 2   --- qdt = quckdt/two
c     iswitch = 3   --- converged.
      iswitch = 0
      qdt = quckdt*two
c
      do jcycle = 2,maxcyc
         icycle = istart+jcycle
         IF(MASWRK) then
            write(iw,9300) icycle,jcycle,iswitch,qdt
            write(ip,9300) icycle,jcycle,iswitch,qdt
            write(IPTRAJ,9300) icycle,jcycle,iswitch,qdt
            endif
         call flshbf(iw)
         call flshbf(ip)
         call flshbf(IPTRAJ)
 9300 format(//,'*********************',
     */,'NEB_run cycle# =',i5,' (jcycle,iswitch,qdt=',i5,i3,f10.5,
     */,'*********************',/)
c
         jFTmax = LFTmax+jcycle-1
c        ------------------------
c
         call NEB_run(iw,n3, num, nbeads, X(LBEADS),
     *            X(LVELOC), X(LENGY), X(LGRAD),
     *            X(LVWORK),X(LTAU1),X(LTAU2),
     *            X(LBFORC),X(LC1WORK),X(LC2WORK),
     *            X(LD1WORK),X(LD2WORK),X(LBDIST),
     *            X(LSTOREI),X(LSTORE),X(LFTrms),
     *            crdtol,toangs,opttol,SPFORC, qdt,
     *            iswitch, X(jFTmax), maswrk,debug)
         call DDI_sync(32032+jcycle)
c
c        ------------------------------------------
         call NEBtrajectory(IPTRAJ,nat,anam,bnam,zan,
     *           nbeads,X(LBEADS),X(LENGY),X(LGRAD),
     *           X(LVELOC),icycle,maswrk,debug)
         call DDI_sync(32033+jcycle)
c
c        Punch out Chem3D input of the current beads.
         if(maswrk) write(ip,9520)
         i0 = LBEADS-1
         do ibead=1,nbeads
            call nebc3d(ip,ibead,nat,ian,x(i0+1),TOANGS,MASWRK)
            i0 = i0 +nat*3
            enddo
         call DDI_sync(32034+jcycle)
c
         if(iswitch.eq.1) qdt = quckdt
         if(iswitch.eq.2) qdt = quckdt/two
         if(iswitch.eq.3) go to 400
c
c.@@@    ************************ for Debug...
c        if(icycle.eq.(istart+50)) go to 400
c        ************************
c        if(icycle.eq.(istart+2)) then
c        if(icycle.eq.(istart+20)) then
c           if(maswrk) write(iw,*)
c    *         'Debug: stop here in nebpath on 2019/03/09...'
c           call abrt
c           endif
c.@@@    ************************
c
         enddo
  400 CONTINUE
      call DDI_sync(32035)
      CALL FLSHBF(IPTRAJ)
c
c     ------------------------------------------
c     hartree --> kcal/mol
      call NEB_autokcal(iw,nat,nbeads,Zmass,X(LBEADS),
     *         X(LENGY),X(LGRAD),X(LFTrms),
     *         X(LFTmax),jcycle,
     *         toangs,tokcal,maswrk,debug)
      call DDI_sync(32036)
      call NEB_autokcal(ip,nat,nbeads,Zmass,X(LBEADS),
     *         X(LENGY),X(LGRAD),X(LFTrms),
     *         X(LFTmax),jcycle,
     *         toangs,tokcal,maswrk,debug)
      call DDI_sync(32037)
c
c     ------------------------------------------
c     Print out restart data into the .dat file...
c     $NEB
      if(maswrk) then
         write(iw,9500) NBEADS,UNTCRD,SPFORC,quckdt,
     *               crdtol,OPTTOL,maxcyc,VIAPNT,(istart+maxcyc),
     *               OPTMZR,TSLOCT, molsym
         write(ip,9500) NBEADS,UNTCRD,SPFORC,quckdt,
     *               crdtol,OPTTOL,maxcyc,VIAPNT,(istart+maxcyc),
     *               OPTMZR,TSLOCT, molsym
         endif
      call DDI_sync(32038)
 9500 FORMAT(//,57('*'),/,57('*'),
     */,'** For a restarting job, you have to keep your initial **',
     */,'** input deck and append the following data into your  **',
     */,'** input deck.                        (SK, 2019/03/11) **',
     */,57('*'),
     */,' $NEB  NBEADS=',i5,10x,'UNTCRD=',a8,
     */,'       SPFORC=',f8.5,7x,'QUCKDT=',f10.5,
     */,'       CRDTOL=',f10.5,5x,'OPTTOL=',f10.5,
     */,'       MAXCYC=',i8,7x,'VIAPNT=.',L1,'.',
     */,'       MORINT=.T.',12x,
     */,'       RESTRT=.T.',12x,'iSTART=',i5,
     */,'       OPTMZR=',a8,7x,'TSLOCT=.',L1,'.',
     */,'       MOLSYM=.',L1,'.',11x,'$END')
c
c     $BEADSX   coordinates & energies (all in atomic unit)
      if(maswrk) then
         call NEBtrajectory(iw,nat,anam,bnam,zan,
     *              nbeads,X(LBEADS),X(LENGY),X(LGRAD),
     *           X(LVELOC),icycle,maswrk,debug)
         call NEBtrajectory(ip,nat,anam,bnam,zan,
     *              nbeads,X(LBEADS),X(LENGY),X(LGRAD),
     *           X(LVELOC),icycle,maswrk,debug)
         endif
      call DDI_sync(32039)
c
c     -----------------------------------------
c     Punch out Chem3D input of the final beads.
      if(maswrk) then
         write(iw,9520)
         write(ip,9520)
         i0 = LBEADS-1
         do ibead=1,nbeads
            call nebc3d(iw,ibead,nat,ian,x(i0+1),TOANGS,MASWRK)
            call nebc3d(ip,ibead,nat,ian,x(i0+1),TOANGS,MASWRK)
            i0 = i0 +nat*3
            enddo
         write(ip,9530)
c        ian --- nat*nbeads
         i0 = 0
         do ibead=1,nbeads
            do i=1,nat
               i0 = i0+1
               ix(i0) = ian(i)
               enddo
            enddo
         call nebc3d(ip,0,nat*nbeads,IX,x(LBEADS),TOANGS,MASWRK)
         endif
      call DDI_sync(32040)
 9520 format('*** Chem3D input in cc1 format for a movie',
     *     /,'    (no atom type and connection tables)')
 9530 format('*** Chem3D input in cc1 format for an overlap image',
     *     /,'    (no atom type and connection tables)')
c
  600 CONTINUE
      call DDI_sync(32041)
c
      CALL RETFM(NEED)
      IF(MASWRK) WRITE(IW,9900)
      CALL TIMIT(1)
      RETURN
C
C                PRINTING TO THE TRAJECTORY FILE
 9900 FORMAT(/,10X,29(1H-),/,10X,'Exit from the NEBpath routine',
     *       /,10X,29(1H-),/)
      END
C*MODULE NEBPATH *DECK NEBCOM
C>
C>    @brief    NEBPATH: Move the coordinates to the center-of-mass
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE nebcom(iw,nat,anam,bnam,ZMASS,C,MASWRK,debug)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      dimension  anam(*),bnam(*),zmass(*),C(3,*)
      dimension  com(3)
      logical    MASWRK, debug
      PARAMETER (zero=0.0d+00)
c
      totm = zero
      do i=1,nat
         totm = totm + zmass(i)
         enddo
      do j=1,3
         com(j)=zero
         do i=1,nat
            com(j)=com(j)+zmass(i)*c(j,i)
            enddo
         enddo
      do j=1,3
         com(j)=com(j)/totm
         enddo
c
      do i=1,nat
         do j=1,3
            c(j,i) = c(j,i) -com(j)
            enddo
         if(MASWRK.and.debug)
     *      WRITE(IW,9020) ANAM(I),BNAM(I),ZMASS(I),(C(j,i),j=1,3)
         enddo
 9020 FORMAT(1x,a8,a2,1x,F10.4,3F18.10)
c
      return
      end
C*MODULE NEBPATH *DECK NEBc3d
C>
C>    @brief    NEBPATH: Print out the input for Chem3d in "cc1" format
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE nebc3d(iw,ibead,nat,ian,C,TOANGS,MASWRK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical      MASWRK
c
      character*2  ASYMB
C
      dimension  C(3,*), ian(*)
      dimension  CA(3)
c
      if(maswrk) write(iw,9000) nat,ibead
      do i=1,nat
         ASYMB = "  "
         if(ian(i).eq.1)   ASYMB = "H "
         if(ian(i).eq.2)   ASYMB = "He"
         if(ian(i).eq.3)   ASYMB = "Li"
         if(ian(i).eq.4)   ASYMB = "Be"
         if(ian(i).eq.5)   ASYMB = "B "
         if(ian(i).eq.6)   ASYMB = "C "
         if(ian(i).eq.7)   ASYMB = "N "
         if(ian(i).eq.8)   ASYMB = "O "
         if(ian(i).eq.9)   ASYMB = "F "
         if(ian(i).eq.10)  ASYMB = "Ne"
c
         if(ian(i).eq.11)  ASYMB = "Na"
         if(ian(i).eq.12)  ASYMB = "Mg"
         if(ian(i).eq.13)  ASYMB = "Al"
         if(ian(i).eq.14)  ASYMB = "Si"
         if(ian(i).eq.15)  ASYMB = "P "
         if(ian(i).eq.16)  ASYMB = "S "
         if(ian(i).eq.17)  ASYMB = "Cl"
         if(ian(i).eq.18)  ASYMB = "Ar"
c
         if(ian(i).eq.19)  ASYMB = "K "
         if(ian(i).eq.20)  ASYMB = "Ca"
c
         if(ian(i).eq.21)  ASYMB = "Sc"
         if(ian(i).eq.22)  ASYMB = "Ti"
         if(ian(i).eq.23)  ASYMB = "V "
         if(ian(i).eq.24)  ASYMB = "Cr"
         if(ian(i).eq.25)  ASYMB = "Mn"
         if(ian(i).eq.26)  ASYMB = "Fe"
         if(ian(i).eq.27)  ASYMB = "Co"
         if(ian(i).eq.28)  ASYMB = "Ni"
         if(ian(i).eq.29)  ASYMB = "Cu"
         if(ian(i).eq.30)  ASYMB = "Zn"
c
         if(ian(i).eq.31)  ASYMB = "Ga"
         if(ian(i).eq.32)  ASYMB = "Ge"
         if(ian(i).eq.33)  ASYMB = "As"
         if(ian(i).eq.34)  ASYMB = "Se"
         if(ian(i).eq.35)  ASYMB = "Br"
         if(ian(i).eq.36)  ASYMB = "Kr"
c
         if(ian(i).eq.37)  ASYMB = "Rb"
         if(ian(i).eq.38)  ASYMB = "Sr"
c
         if(ian(i).eq.39)  ASYMB = "Y "
         if(ian(i).eq.40)  ASYMB = "Zr"
         if(ian(i).eq.41)  ASYMB = "Nb"
         if(ian(i).eq.42)  ASYMB = "Mo"
         if(ian(i).eq.43)  ASYMB = "Tc"
         if(ian(i).eq.44)  ASYMB = "Ru"
         if(ian(i).eq.45)  ASYMB = "Rh"
         if(ian(i).eq.46)  ASYMB = "Pd"
         if(ian(i).eq.47)  ASYMB = "Ag"
         if(ian(i).eq.48)  ASYMB = "Cd"
c
         if(ian(i).eq.49)  ASYMB = "In"
         if(ian(i).eq.50)  ASYMB = "Sn"
         if(ian(i).eq.51)  ASYMB = "Sb"
         if(ian(i).eq.52)  ASYMB = "Te"
         if(ian(i).eq.53)  ASYMB = "I "
         if(ian(i).eq.54)  ASYMB = "Xe"
c
         if(ian(i).eq.55)  ASYMB = "Cs"
         if(ian(i).eq.56)  ASYMB = "Ba"
c
         if(ian(i).eq.57)  ASYMB = "La"
         if(ian(i).eq.58)  ASYMB = "Cs"
         if(ian(i).eq.59)  ASYMB = "Cs"
         if(ian(i).eq.60)  ASYMB = "Cs"
         if(ian(i).eq.61)  ASYMB = "Cs"
c
         if(ian(i).eq.72)  ASYMB = "Hf"
         if(ian(i).eq.73)  ASYMB = "Ta"
         if(ian(i).eq.74)  ASYMB = "W "
         if(ian(i).eq.75)  ASYMB = "Re"
         if(ian(i).eq.76)  ASYMB = "Os"
         if(ian(i).eq.77)  ASYMB = "Ir"
         if(ian(i).eq.78)  ASYMB = "Pt"
         if(ian(i).eq.79)  ASYMB = "Au"
         if(ian(i).eq.80)  ASYMB = "Hg"
c
         if(ian(i).eq.81)  ASYMB = "Tl"
         if(ian(i).eq.82)  ASYMB = "Pb"
         if(ian(i).eq.83)  ASYMB = "Bi"
         if(ian(i).eq.84)  ASYMB = "Po"
         if(ian(i).eq.85)  ASYMB = "At"
         if(ian(i).eq.86)  ASYMB = "Rn"
c
         do j=1,3
            CA(j)=C(j,i)*TOANGS
            enddo
         if(maswrk) write(iw,9100) ASYMB,i,(cA(j),j=1,3)
         enddo
 9000 format(i5,'      #bead =',i5)
 9100 format(a2,i5,3f12.6)
c
      return
      end
C*MODULE NEBPATH *DECK NEBdchk
C>
C>    @brief    NEBPATH: Examine the distances between two atoms
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE nebdchk(iw,nat,anam,bnam,Zmass,c0,c1,crdtol,MASWRK)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      dimension  Zmass(*)
      dimension  c0(3,*), c1(3,*)
      dimension  anam(*), bnam(*)
      PARAMETER (zero=0.0d+00)
      logical    MASWRK
c
      if(MASWRK) WRITE(IW,9000)
c
      ierr = 0
      do i=1,nat
         xdisp = zero
         do j=1,3
            xdisp = xdisp + Zmass(i)*(c0(j,i)-c1(j,i))**2
            enddo
         xdisp = sqrt(xdisp)
         if(MASWRK) WRITE(IW,9020) ANAM(I),BNAM(I),ZMASS(I)
     *                            ,xdisp
         if(xdisp.gt.crdtol) ierr = ierr+1
         enddo
 9000 FORMAT(/,'*** Getting into NEBdchk routine ***')
 9020 FORMAT(5x,a8,a2,1x,F10.4,F18.10,' sqrt(amu)*bohr')
c
      return
      end
C*MODULE NEBPATH *DECK NEBanglr
C>
C>    @brief    NEBPATH: Erase the angular momentaum between two sets of coordinates
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE nebanglr(iw,nat,anam,bnam,ian,xmass,cs0,ct1,crdtol,
     *           ct1new,ct1bak,dist1,dist2,toangs,MASWRK,debug)
c     Need work area: cnew,cold, dist1(), dist2()
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      dimension  xmass(nat)
      dimension  cs0(3,nat), ct1(3,nat)
      dimension  anam(nat), bnam(nat), ian(nat)
      logical    MASWRK, debug
c
CCCCC CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC CCCCC
c     Rotation of the coordinates for the second (triplet) state...
CCCCC Angular momentum...                                  CCCCC
CCCCC                             Shiro KOSEKI, 2011/12/11 CCCCC
CCCCC CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC CCCCC
c     subroutine trprot(natom,cs0,ct1,xmass,debug,iw)
c
      PARAMETER (zero=0.0D+00)
      PARAMETER (one=1.0d+00)
      PARAMETER (two=2.0d+00)
      PARAMETER (pi=dacos(-one))
      PARAMETER (pi180=180.0d+00/pi)
      PARAMETER (amtol=1.0d-10)
      PARAMETER (dtol=5.0d+00)
c     PARAMETER    (amtol=1.0d-12, dtol=5.0d+00)
c                                  ~~~~~~~~~~~~ *****
c                   0.000000000010
c                     123456789012
c
      DIMENSION    ct1new(3,nat), ct1bak(3,nat)
      DIMENSION    DIST1(nat,nat)
      DIMENSION    DIST2(nat,nat)
c
      dimension    com(3)
      dimension    rot(3,3), eig(3), rinv(3,3), rbak(3,3)
      dimension    chk(3,3), ekeep(3)
      dimension    work(9),ipiv(3)
c
      PARAMETER (itermx=100)
      dimension    record(1:itermx), xdeg(1:3,1:itermx)
      dimension    determinant(1:itermx)
c
      if(MASWRK) WRITE(IW,9000)
c     if(maswrk) write(iw,*) 'Debug: debug=',debug
 9000 FORMAT(/,'*** Getting into NEBanglr routine ***')
c
c     clear arrays...
      record(1:itermx)=zero
      xdeg(1:3,1:itermx)=zero
      call DDI_sync(320100)
c
c     -------------------------------------------------
c     cs0 and ct1 in bohr...
c     -------------------------------------------------
c     already move to the Center of mass?
      call nebcom(iw,nat,anam,bnam,xMASS,cs0,MASWRK,debug)
      call nebcom(iw,nat,anam,bnam,xMASS,ct1,MASWRK,debug)
      call DDI_sync(320101)
c
c     Just check...
      call NEBdstmtx(iw,nat,cs0,dist1,maswrk,debug)
c
c     Caution: dist1 will be used.
      call NEBdstmtx(iw,nat,ct1,dist1,maswrk,debug)
      call DDI_sync(320102)
c
      if(maswrk.and.debug) then
         write(iw,*) ' '
         write(iw,*) 'Debug: cs0...'
         call nebc3d(iw,0,nat,ian,cs0,TOANGS,MASWRK)
         write(iw,*) ' '
         write(iw,*) 'Debug: ct1...'
         call nebc3d(iw,0,nat,ian,ct1,TOANGS,MASWRK)
c
         write(iw,*) ' '
         write(iw,*) 'Debug: xmass...'
         do i=1,nat
            write(iw,9012) i,xmass(i)
            enddo
         endif
      call DDI_sync(320103)
 9012 format(i5,f12.5)
c
c     Angular momentum...
      iter = 0
      ireverse = 0
  100 continue
c     Move to the Center of mass? (not necessary...?)
      call nebcom(iw,nat,anam,bnam,xMASS,cs0,MASWRK,debug)
      call nebcom(iw,nat,anam,bnam,xMASS,ct1,MASWRK,debug)
      call DDI_sync(320104)
c
      do j=1,3
         com(j) = zero
         enddo
      do i=1,nat
         com(1) = com(1) +xmass(i)*( cs0(2,i)*(ct1(3,i)-cs0(3,i))
     *                              -cs0(3,i)*(ct1(2,i)-cs0(2,i)) )
         com(2) = com(2) +xmass(i)*( cs0(3,i)*(ct1(1,i)-cs0(1,i))
     *                              -cs0(1,i)*(ct1(3,i)-cs0(3,i)) )
         com(3) = com(3) +xmass(i)*( cs0(1,i)*(ct1(2,i)-cs0(2,i))
     *                              -cs0(2,i)*(ct1(1,i)-cs0(1,i)) )
         enddo
      totamt = dsqrt(com(1)**2 +com(2)**2 +com(3)**2)
      if(maswrk.and.debug) write(iw,20) (com(j),j=1,3)
      call DDI_sync(320105)
   20 format(/,'Angular momentum =',3f15.8)
c
      iter = iter+1
      record(iter) = totamt
      if(iter.gt.itermx) then
         if(maswrk) then
            write(iw,*) 'Failed to converge...'
            write(iw,9200) iter
            do i=1,iter
               write(iw,9022) i,record(i),(xdeg(j,i),j=1,3),
     *                        determinant(i)
               enddo
            call abrt
            endif
         endif
      call DDI_sync(320106)
 9022 format(i5,3x,f20.12,'   (',3f10.5,')',d20.10)
c
c     When the angular momentum increases, ...
c*    if((iter.gt.1).and.(record(iter).gt.record(iter-1))) call abrt
c     if((iter.gt.1).and.(record(iter).gt.record(iter-1))) then
      if(iter.gt.1) then
      if(record(iter).gt.record(iter-1)) then
          afact = 10.0d+00
          if(totamt.gt.100.0d+00) afact = 100.0d+00
          if(totamt.gt.200.0d+00) afact = 200.0d+00
          if(totamt.gt.300.0d+00) afact = 300.0d+00
          if(totamt.gt.500.0d+00) afact = 500.0d+00
          if(totamt.gt.1000.0d+00) afact = 1000.0d+00
          if(ireverse.eq.0) then
            ax = -ax/afact
            ay = -ay/afact
            az = -az/afact
            else
            ax =  ax/afact
            ay =  ay/afact
            az =  az/afact
            endif
          do i=1,nat
             do j=1,3
                ct1(j,i) = ct1bak(j,i)
                enddo
             enddo
          ireverse = ireverse +1
          go to 66
          endif
          endif
c
c     Examine the convergence...
      if(totamt.lt.amtol) then
         xdeg(1:3,iter) = zero
         go to 200
         endif
c
c     Get angles for the rotation of ct1...
c     This is the first-order approximation for a rotational matrix.
      ireverse = 0
      eig(1:3) = zero
      rot(1:3,1:3) = zero
c     do i=1,3
c        eig(i) = zero
c        do j=1,3
c           rot(j,i) = zero
c           enddo
c        enddo
      call DDI_sync(320107)
c
c     Rotation matrix...
      do i=1,nat
         rot(1,1) = rot(1,1) +xmass(i)*cs0(3,i)*ct1(1,i)
         rot(1,2) = rot(1,2) -xmass(i)*cs0(2,i)*ct1(1,i)
         rot(1,3) = rot(1,3) -xmass(i)*cs0(2,i)*ct1(2,i)
     *                       -xmass(i)*cs0(3,i)*ct1(3,i)
         rot(2,1) = rot(2,1) +xmass(i)*cs0(3,i)*ct1(2,i)
         rot(2,2) = rot(2,2) +xmass(i)*cs0(3,i)*ct1(3,i)
     *                       +xmass(i)*cs0(1,i)*ct1(1,i)
         rot(2,3) = rot(2,3) +xmass(i)*cs0(1,i)*ct1(2,i)
         rot(3,1) = rot(3,1) -xmass(i)*cs0(1,i)*ct1(1,i)
     *                       -xmass(i)*cs0(2,i)*ct1(2,i)
         rot(3,2) = rot(3,2) -xmass(i)*cs0(2,i)*ct1(3,i)
         rot(3,3) = rot(3,3) +xmass(i)*cs0(1,i)*ct1(3,i)
         eig(1) = eig(1) +xmass(i)*cs0(2,i)*ct1(3,i)
     *                   -xmass(i)*cs0(3,i)*ct1(2,i)
         eig(2) = eig(2) +xmass(i)*cs0(3,i)*ct1(1,i)
     *                   -xmass(i)*cs0(1,i)*ct1(3,i)
         eig(3) = eig(3) +xmass(i)*cs0(1,i)*ct1(2,i)
     *                   -xmass(i)*cs0(2,i)*ct1(1,i)
         enddo
      call DDI_sync(320108)
c
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "Rotation matrix..."
         endif
      do i=1,3
         if(maswrk.and.debug) write(iw,9050) (rot(i,j),j=1,3)
         ekeep(i) = eig(i)
         do j=1,3
            rinv(i,j) = rot(i,j)
            rbak(i,j) = rot(i,j)
            enddo
         enddo
      determinant(iter)
     *   = rot(1,1)*rot(2,2)*rot(3,3)
     *    +rot(1,2)*rot(2,3)*rot(3,1)
     *    +rot(1,3)*rot(2,1)*rot(3,2)
     *    -rot(1,1)*rot(3,2)*rot(2,3)
     *    -rot(1,2)*rot(2,1)*rot(3,3)
     *    -rot(1,3)*rot(2,2)*rot(3,1)
      if(maswrk.and.debug) then
         write(iw,9052) determinant(iter)
         write(iw,*) " "
         write(iw,*) "B matrix..."
         write(iw,9050) (eig(j),j=1,3)
         endif
      call DDI_sync(320109)
 9050 format(3f15.8)
 9052 format('||det|| =',d20.10)
c
c*    if(determinant(iter).lt.zero) stop
c
c     ------------------------------------------------------
c     inverse matrix of rot: Intel MKL routine...
      call dgels('N',3,3,1,rinv,3,eig,3,work,9,info)
c                 1  2 3 4 5    6  7  8 9    10 11
      if(maswrk.and.(info.ne.0)) then
         write(*,*) 'Error in dgels: info=',info
         call abrt
         endif
      call DDI_sync(320110)
c
c     answer = eig(j)
c     rot*eig = ekeep ?
c
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "Answer..."
         write(iw,9050) (eig(j),j=1,3)
         endif
c
c     Debug...
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "rot*eig..."
         endif
      do i=1,3
         chk(i,1) = zero
         do j=1,3
            chk(i,1) = chk(i,1) +rot(i,j)*eig(j)
            enddo
         enddo
      if(maswrk.and.debug) then
         write(iw,9050) (chk(i,1),i=1,3)
         write(iw,9050) (ekeep(i),i=1,3)
         endif
      errx = zero
      do i=1,3
         do j=1,3
            if(dabs(rot(j,i)).gt.errx) errx=dabs(rot(j,i))
            enddo
         enddo
      errx = errx*1.0d-10
      do i=1,3
         diff = dabs(chk(i,1)-ekeep(i))
         if(diff.gt.errx) call abrt
         enddo
      call DDI_sync(320111)
c
c
c     Rotational angles...
      ax = eig(1)
      ay = eig(2)
      az = eig(3)
c
c     declear parameters...
c     pi = dacos(-one)
c     dx = ax/pi*180.0d+00
c     dy = ay/pi*180.0d+00
c     dz = az/pi*180.0d+00
c     pi180 = 180.0d+00/pi
c
      dx = ax*pi180
      dy = ay*pi180
      dz = az*pi180
      atol = dtol/pi180
      if(maswrk.and.debug) then
         write(iw,9060) ax,ay,az," rad."
         write(iw,9060) dx,dy,dz," deg."
         write(iw,9062) dtol,atol
         endif
c
   66 continue
      if((dabs(ax).gt.atol).or.(dabs(ay).gt.atol).or.
     *   (dabs(az).gt.atol)) then
         axyz = dabs(ax)
         if(dabs(ay).gt.axyz) axyz = dabs(ay)
         if(dabs(az).gt.axyz) axyz = dabs(az)
c
         if(axyz.eq.zero) then
            afact = zero
            else
            afact = atol/axyz
            endif
c
         ax = ax*afact
         ay = ay*afact
         az = az*afact
c        dx = ax/pi*180.0d+00
c        dy = ay/pi*180.0d+00
c        dz = az/pi*180.0d+00
         dx = ax*pi180
         dy = ay*pi180
         dz = az*pi180
         if(maswrk.and.debug) then
            write(iw,9064) dtol
            write(iw,9060) ax,ay,az," rad."
            write(iw,9060) dx,dy,dz," deg."
            endif
         endif
      xdeg(1,iter) = dx
      xdeg(2,iter) = dy
      xdeg(3,iter) = dz
      call DDI_sync(320112)
 9060 format('Rotational angles =',3f12.5,a5)
 9062 format('Maximum angle     =',f12.5,' [deg] =',f12.5,' [rad]')
 9064 format('Use ',f3.1,' degree for rotation...')
c
c     Rotational matrix...
      rot(1,1) =  dcos(ax)*dcos(ay)
      rot(1,2) = -dsin(ax)*dcos(az) -dcos(ax)*dsin(ay)*dsin(az)
      rot(1,3) =  dsin(ax)*dsin(az) -dcos(ax)*dsin(ay)*dcos(az)
      rot(2,1) =  dsin(ax)*dcos(ay)
      rot(2,2) =  dcos(ax)*dcos(az) -dsin(ax)*dsin(ay)*dsin(az)
      rot(2,3) = -dcos(ax)*dsin(az) -dsin(ax)*dsin(ay)*dcos(az)
      rot(3,1) =  dsin(ay)
      rot(3,2) =  dcos(ay)*dsin(az)
      rot(3,3) =  dcos(ay)*dcos(az)
c
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "Rotational matrix..."
         endif
      do i=1,3
         if(maswrk.and.debug) write(iw,9050) (rot(i,j),j=1,3)
         chk(i,1) = rot(i,1)**2 + rot(i,2)**2 +rot(i,3)**2
         chk(i,2) = rot(1,i)**2 + rot(2,i)**2 +rot(3,i)**2
         enddo
      if(maswrk.and.debug) then
         write(iw,9180) (chk(i,1),i=1,3)
         write(iw,9180) (chk(i,2),i=1,3)
         endif
      call DDI_sync(320113)
 9180 format('Debug: Norm =',3f15.10)
c
c     New coordinate...
      if(maswrk.and.debug) then
         write(iw,*) " "
         write(iw,*) "New coordinates of the next bead..."
         endif
      dmax = zero
      do i=1,nat
         do j=1,3
            ct1new(j,i) = rot(j,1)*ct1(1,i)
     *                   +rot(j,2)*ct1(2,i)
     *                   +rot(j,3)*ct1(3,i)
            enddo
         dist = dsqrt( (ct1new(1,i)-ct1(1,i))**2
     *                +(ct1new(2,i)-ct1(2,i))**2
     *                +(ct1new(3,i)-ct1(3,i))**2 )
         if(dist.gt.dmax) dmax=dist
         distm = dist*dsqrt(xmass(i))
         if(maswrk.and.debug)
     *      write(iw,9010) i,xmass(i),(ct1new(j,i),j=1,3),dist,distm
         enddo
      if(maswrk.and.debug) write(iw,9182) dmax
      call DDI_sync(320114)
 9010 format(i3,f8.1,5f15.8)
 9182 format('Debug: maximum displace of atoms =',f15.10)
c
      do i=1,nat
         do j=1,3
            ct1bak(j,i) = ct1(j,i)
            ct1(j,i) = ct1new(j,i)
            enddo
         enddo
      call NEBdstmtx(iw,nat,ct1,dist2,maswrk,debug)
      call NEBdstchk(iw,nat,dist1,dist2,maswrk)
      go to 100
c
  200 continue
      if(maswrk) then
         write(iw,9200) iter
         do i=1,iter
            write(iw,9022) i,record(i),(xdeg(j,i),j=1,3),
     *                     determinant(i)
            enddo
         endif
      call DDI_sync(320115)
 9200 format(/,'*** Record of coordinate rotation ***',
     *  '    iteration =',i5,
     */,'#Iteration  Angular Momentum   Rotation angles [deg.] (x,y,z)',
     *  '    Determinant')
c
      return
      end
C*MODULE NEBPATH *DECK NEBdstchk
C>
C>    @brief    NEBPATH: Examine the distances between two atoms
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEBdstchk(iw,nat,dist1,dist2,maswrk)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      dimension  dist1(nat,nat)
      dimension  dist2(nat,nat)
      logical    maswrk
c
      PARAMETER (zero=0.0d+00)
      PARAMETER (one=1.0d+00)
      PARAMETER (two=2.0d+00)
c     parameter (dtol = 1.0d-05)
      PARAMETER (dtol = 1.0d-08)
c
c*    if(maswrk) write(iw,9000)
      ierr = 0
      do i=1,nat
         do j=1,nat
            diff=dabs(dist1(j,i)-dist2(j,i))
            if(maswrk.and.(diff.gt.dtol)) then
               ierr = ierr+1
               write(iw,9100) j,i,dist1(j,i),dist2(j,i),diff
               endif
            enddo
         enddo
c*    if(maswrk) write(iw,9110) ierr
 9000 format('NEBdstchk: the coordinates for the next bead',
     *       ' should be maintained after rotation.')
 9100 format('Error (dstchk):',2i5,3f12.6)
 9110 format('NEBdstchk: ierr=',i5)
      return
      end
C*MODULE NEBPATH *DECK NEBdstmtx
C>
C>    @brief    NEBPATH: Create the distance matrix
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEBdstmtx(iw,nat,cc,dist,maswrk,debug)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (zero=0.0d+00)
      PARAMETER (one=1.0d+00)
      PARAMETER (two=2.0d+00)
      dimension  cc(3,nat)
      dimension  dist(nat,nat)
      logical    MASWRK, debug
c
      if(maswrk.and.debug) write(iw,*) 'Debug: coordinates in bohr...'
c
      do i=1,nat
         do j=1,nat
            dist(j,i) = dsqrt( (cc(1,j)-cc(1,i))**2
     *                        +(cc(2,j)-cc(2,i))**2
     *                        +(cc(3,j)-cc(3,i))**2)
            enddo
         enddo
c
      if(nat.gt.10) return
      if(maswrk.and.debug) then
         write(iw,*) ' '
         write(iw,*) 'Distance matrix in bohr ---'
         do i=1,nat
            write(iw,9100) i,(dist(i,j),j=1,nat)
            enddo
         endif
 9100 format(i3,12f10.6)
c
      return
      end
C*MODULE NEBPATH *DECK NEBcoord
C>
C>    @brief    NEBPATH: Create the distance matrix
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEBcoord(ir,iw,keywrd,nat,c4,maswrk,debug)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER (zero=0.0d+00)
      PARAMETER (one=1.0d+00)
      PARAMETER (two=2.0d+00)
      dimension    c4(4,nat)
      character*8  keywrd
      character*80 xline
      logical      maswrk,debug
c
      if(maswrk.and.debug)
     *   write(iw,*) 'Debug: getting into NEBcoord'
      if(maswrk.and.debug)
     *   write(iw,*) 'ir,iw =',ir,iw
c
      rewind ir
  100 continue
      read(ir,1,err=900,end=900) xline
c     if(maswrk.and.debug) write(iw,1) xline
      call nebcapital(xline)
      if(xline(1:8).ne.keywrd) go to 100
      do i=1,nat
         if(maswrk.and.debug) write(iw,*) 'Debug: ',i
         read(ir,1,err=900,end=900) xline
c        if(maswrk.and.debug) write(iw,1) xline
         do j=2,80
            if(xline(j:j).eq.' ') go to 120
            enddo
         go to 900
c
  120    continue
         i0 = j
         if(maswrk.and.debug) write(iw,2) (xline(j:j),j=i0,80)
         read(xline(i0:80),*,err=900,end=900) (c4(j,i),j=1,4)
         enddo
c
      return
c
  900 continue
      if(maswrk) write(iw,9120) keywrd,xline
      call abrt
      return
    1 format(a80)
    2 format(80a1)
 9120 format(/,'Error: could not find ',a8,//,a80)
      end
C*MODULE NEBPATH *DECK NEBcapital
C>
C>    @brief    NEBPATH: Change the characters into capitals
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine nebcapital(xline)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      character*1  xline(80)
c
      do i=1,80
         if(xline(i).eq.'a') xline(i)='A'
         if(xline(i).eq.'b') xline(i)='B'
         if(xline(i).eq.'c') xline(i)='C'
         if(xline(i).eq.'d') xline(i)='D'
         if(xline(i).eq.'e') xline(i)='E'
         if(xline(i).eq.'f') xline(i)='F'
         if(xline(i).eq.'g') xline(i)='G'
         if(xline(i).eq.'h') xline(i)='H'
         if(xline(i).eq.'i') xline(i)='I'
         if(xline(i).eq.'j') xline(i)='J'
         if(xline(i).eq.'k') xline(i)='K'
         if(xline(i).eq.'l') xline(i)='L'
         if(xline(i).eq.'m') xline(i)='M'
         if(xline(i).eq.'n') xline(i)='N'
         if(xline(i).eq.'o') xline(i)='O'
         if(xline(i).eq.'p') xline(i)='P'
         if(xline(i).eq.'q') xline(i)='Q'
         if(xline(i).eq.'r') xline(i)='R'
         if(xline(i).eq.'s') xline(i)='S'
         if(xline(i).eq.'t') xline(i)='T'
         if(xline(i).eq.'u') xline(i)='U'
         if(xline(i).eq.'v') xline(i)='V'
         if(xline(i).eq.'w') xline(i)='W'
         if(xline(i).eq.'x') xline(i)='X'
         if(xline(i).eq.'y') xline(i)='Y'
         if(xline(i).eq.'z') xline(i)='Z'
         enddo
c
      return
      end
C*MODULE NEBPATH *DECK NEB_linear_interp
C>
C>    @brief    NEBPATH: linear interpolation between reactant and product (via-point)
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_linear_interp(n3, nbeads, cc)
c           call NEB_linear_interp(nat*3,nbeads,X(LBEADS))
c
c     The subroutine of linear interpolation between 1st and last beads
c     *******************************************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: n3, nbeads
      double precision, intent(inout) :: cc(n3,nbeads)
      integer :: i, ibead
c
c     n3        : n3 = 3 * the number of atoms
c     nbeads    : the number of beads
c     cc        : Coordinates of atoms in all beads
c   
c     New beads are linear interpolated between 1st and last beads.
      do ibead = 2, nbeads - 1
         do i = 1, n3
            cc(i,ibead) = cc(i,1) +dble(ibead - 1)*(cc(i,nbeads) 
     *                    -cc(i,1))/dble(nbeads - 1)
            end do
         end do
      end subroutine NEB_linear_interp
C*MODULE NEBPATH *DECK NEB_idpp_interp
C>
C>    @brief    NEBPATH: IDPP modification of the linear interpolation
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_idpp_interp(iw,nat, nbeads, X, velo,v,f,ian,Zmass,
     *           crdtol,toangs, tau,tau_plus,tau_minus,F_T,Fs_pa,
     *           dc,dd,di, maxcycle, quickdt, spring, f_conv,
     *           maswrk,debug)
c
      use mx_limits, only: mxatm,mxao
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      ! The subroutine of image dependent pair potential (IDPP) interpolation
      !
      ! References
      ! (1) Smidstrup, S.; Pedersen, A.; Stokbro, K.; Jonsson, H. Improved Initial
      ! Guess for Minimum Energy Path Calculations. J. Chem. Phys. 2014, 140 (21),
      ! 214106.
      !
      ! (2) Halgren, T. A.; Lipscomb, W. N. The Synchronous-Transit Method for
      ! Determining Reaction Pathways and Locating Molecular Transition States.
      ! Chem. Phys. Lett. 1977, 49 (2), 225-232.
      !
      !*******************************************************
      integer, intent(in) :: ian(nat), maxcycle
      double precision, intent(in) :: quickdt, spring, f_conv
      double precision, intent(inout) :: x(1:3,1:nat,nbeads)
      double precision, intent(inout) :: velo(1:3,1:nat,1:nbeads)
      double precision :: di(1:nat,1:nat,1:nbeads), d1, dn
      double precision :: f(1:3,1:nat,1:nbeads)
      double precision :: v(1:nbeads)
      double precision :: tau(1:3,1:nat)
      double precision :: tau_plus(1:3,1:nat)
      double precision :: tau_minus(1:3,1:nat)
c
      double precision :: F_T(1:3,1:nat), Fs_pa(1:3,1:nat)
c     double precision    C1WORK(nat*3),C2WORK(nat*3)
c
      double precision :: tmp, tmpvec(1:3)
      integer :: i, ii, j, ibead, icycle
      double precision :: f_sum, f_max, v_sum, v_max, NEB_euclid_norm
      double precision :: NEB_unit_vec, NEB_dot_prod2
c
      double precision  crdtol,toangs
      double precision  Zmass(nat)
c
      double precision  dc(nat,nat),dd(nat,nat)
c     double precision  D1WORK(nat,nat),D2WORK(nat,nat)
      logical           maswrk, debug
c
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (ONE=1.0D+00)
      PARAMETER (TWO=2.0d+00)
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
c
      if(maswrk) write(iw,9000)
 9000 format(/,'*** Getting into NEB_idpp_interp routine ***',/)
c
      ! nat       : number of atoms
      n3 = nat*3
c
      ! nbeads    : number of beads
      ! ian       : atomic number
      ! x = xx    : Coordinates of atoms in all beads
      ! velo      : Velocity for quick-min
      ! quickdt=dt: Step size for quick-min
      ! di        : Distances between atoms in interpolated image
      !             The di is calculated using linear interpolation based on the
      !             values of d1 and dn (described later).
      !             This value is an ideal value that is different from the
      !             actual molecular structure.
      ! d1        : Distances between atoms in 1st image
      ! dn        : Distances between atoms in last image
      ! v         : Image dependent pair potential (IDPP)
      ! f         : IDPP force (Negative gradient of IDPP)
      ! tau       : Tangent vector to the path
      ! tau_plus  : Forward difference
      ! tau_minus : Backward difference
      ! F_T       : Force in the direction perpendicular to the tangent vector
      ! Fs_pa     : Spring force in the direction parallel to the tangent vector
      ! n         : The number of atoms (n = n3/3)
      ! maxcycle  : Maximum number of IDPP optimization iteration
      ! spring    : Spring constant of NEB
      ! f_conv    : Threshold of force. If (f_sum < f_conv) stop
      ! f_sum     : Sum of the forces applied to the 2nd to N-1th beads
      ! f_max     : Muximum of the forces applied to the 2nd to N-1th beads
      ! v_sum     : Sum of the velocities applied to the 2nd to N-1th beads
      ! v_max     : Muximum of the velocities applied to the 2nd to N-1th beads
c
      ! Debug
      if(maswrk.and.debug) then
         write(iw,'(a,5i5)') 'Debug: iw,nat,n3,nbeads =',
     *                               iw,nat,n3,nbeads
         do ibead=1,nbeads
            write(iw,*) nat,'   --- Debug: ibead =',ibead
            ie = 0
            do i=1,nat
               write(iw,'(i3,3f12.6)') ian(i),(x(j,i,ibead),j=1,3)
               enddo
            enddo
         endif
      call DDI_sync(320120)
c
      !------------------------------------------
      !-- Calc. di
      !   di: distances between atoms in interpolated image
      !   d1: distances between atoms in 1st image
      !   dn: distances between atoms in last image
      call NEBdstmtx(iw,nat,x(1,1,1),di(1,1,1),maswrk,debug)
      call NEBdstmtx(iw,nat,x(1,1,nbeads),di(1,1,nbeads),maswrk,debug)
      do i=1,nat
         do j=1,nat
            dd(j,i) = di(j,i,nbeads)-di(j,i,1)
            dd(j,i) = dd(j,i)/float(nbeads-1)
            enddo
         enddo
      call DDI_sync(320121)
c
      do ibead=2,(nbeads-1)
         if(maswrk.and.debug) write(iw,9002) ibead
         do i=1,nat
            do j=1,nat
               di(j,i,ibead)=di(j,i,ibead-1)+dd(j,i)
               enddo
            enddo
         if(maswrk.and.debug) then
            do i=1,nat
               if(nat.le.10) then
                  write(iw,'(10f8.3)') (di(j,i,ibead),j=1,nat)
                  else
                  write(iw,'(10f8.3)') (di(j,i,ibead),j=1,10)
                  endif
               enddo
            endif
         end do
      call DDI_sync(320122)
 9002 format(/,'Debug: linear interporation of distance matrix',
     *         ' at #bead=',i3)
c
c     !------------------------------------------
c     !-- Main cycles
      do icycle=1, maxcycle
         !------------------------------------------
         !-- Superimposition of all images
         if(maswrk) write(iw,9100) icycle
c        call coord_fit(n3/3, nbeads, atmnum, x(1:n3,1:nbeads), 1)
c        call coord_fit(n3/3, nbeads, ian,    x(1:n3,1:nbeads), 1)
         do i=1,(nbeads-1)
            if(maswrk.and.debug) write(iw,9102) i
c
c           ??? necessary... ?
            call NEBanglr(iw,nat,anam,bnam,ian,Zmass,
     *           X(1,1,i),X(1,1,i+1),crdtol,
     *           tau_plus,tau_minus,dc,dd,toangs,MASWRK,debug)
            enddo
 9100 format(/,'# Cycle   =',i5)
 9102 format(/,'# i(bead) =',i5)
c
         !------------------------------------------
         !-- Estimate energies(v) and forces(f) of IDPP
         if(maswrk) write(iw,*) '*** NEB_idpp_estimate ---'
         call NEB_idpp_estimate(iw,nat,nbeads, x(1:3,1:nat,1:nbeads), 
     *           f(1:3,1:nat,1:nbeads), v(1:nbeads),
     *           dc(1:nat,1:nat),di(1:nat,1:nat,1:nbeads),
     *           maswrk,debug)
c
         ! Debug
         if(maswrk.and.debug) then
            write(iw,'(a)') 'fx,fy,fz --- '
            do ibead=1,nbeads
               write(iw,*) 'ibead=',ibead
               do i=1,nat
                  write(iw,'(3f18.8)') (f(j,i,ibead),j=1,3)
                  end do
               write(iw,*) 'v(',ibead,')=',v(ibead)
               enddo
            endif
c
         !------------------------------------------
         !-- End images conditions
         !   Optimize, fix, free-end etc.
         !   These are not supported new.
   
         !------------------------------------------
         !-- Intermediate images conditions
         !   Neb forces are calculated here.
         !   Foeces of end beads(1st and last beads) are not modified.
         do ibead = 2, nbeads-1
            if(maswrk.and.debug) write(iw,*) 'Debug: ibead=',ibead
c
            ! Calculation of tangent vectors along the path
            tau_plus(1:3,1:nat) = X(1:3,1:nat,ibead+1)
     *                           -X(1:3,1:nat,ibead)
            if(maswrk.and.debug) then
               write(iw,*) 'Debug: tau_plus'
               do i=1,nat
                  write(iw,'(3f18.8)') (tau_plus(j,i),j=1,3)
                  end do
               endif
c
            tau_minus(1:3,1:nat) = X(1:3,1:nat,ibead)
     *                            -X(1:3,1:nat,ibead-1)
            if(maswrk.and.debug) then
               write(iw,*) 'Debug: tau_minus'
               do i=1,nat
                  write(iw,'(3f18.8)') (tau_minus(j,i),j=1,3)
                  end do
               endif
c
            tau(1:3,1:nat) = tau_plus(1:3,1:nat)
     *                      +tau_minus(1:3,1:nat)
c           tau(1:3,1:nat) = X(1:3,1:nat,ibead+1)
c    *                      -X(1:3,1:nat,ibead-1)
            if(maswrk.and.debug) then
               write(iw,*) 'Debug: tau_1'
               do i=1,nat
                  write(iw,'(3f18.8)') (tau(j,i),j=1,3)
                  end do
               endif
c
c           tau(1:3,1:nat) = NEB_unit_vec(n3, tau(1:3,1:nat))
            call NEB_unit_vec2(n3,tau(1:3,1:nat))
            if(maswrk.and.debug) then
               write(iw,*) 'Debug: tau_2'
               do i=1,nat
                  write(iw,'(3f18.8)') (tau(j,i),j=1,3)
                  end do
               endif
c
            ! Calculation of perpendicular forces
            ! These forces are perpendicular to the tangent vectors.
            F_T(1:3,1:nat) = f(1:3,1:nat,ibead)
     *         -NEB_dot_prod2(n3,f(1:3,1:nat,ibead),tau(1:3,1:nat))
     *         *tau(1:3,1:nat)
c
            if(maswrk.and.debug) then
               write(iw,*) 'Debug: F_T'
               do i=1,nat
                  write(iw,'(3f18.8)') (F_T(j,i),j=1,3)
                  end do
               endif

            ! Calculation of spring forces
            ! These forces are parallel to the tangent vectors.
            Fs_pa(1:3,1:nat) = tau_plus(1:3,1:nat)
     *                        -tau_minus(1:3,1:nat)
c           Fs_pa(1:3,1:nat) = X(1:3,1:nat,ibead+1)
c    *                    -two*X(1:3,1:nat,ibead)
c    *                        +X(1:3,1:nat,ibead-1)
            if(maswrk.and.debug) then
               write(iw,'(a,f10.5)') 'Debug: Fs_pa'
               do i=1,nat
                  write(iw,'(3f18.8)') (Fs_pa(j,i),j=1,3)
                  end do
               endif
c
            Fs_pa(1:3,1:nat) = spring
     *        *NEB_dot_prod2(n3, Fs_pa(1:3,1:nat),tau(1:3,1:nat))
     *        *tau(1:3,1:nat)
c
            if(maswrk.and.debug) then
               write(iw,'(a,f10.5)') 'Debug: Fs_pa, spring =',spring
               do i=1,nat
                  write(iw,'(3f18.8)') (Fs_pa(j,i),j=1,3)
                  end do
               endif
c
            ! Calclation of resultant forces (NEB forces)
            ! Force values are overwritten here.
            f(1:3,1:nat,ibead) = F_T(1:3,1:nat) + Fs_pa(1:3,1:nat)
c
            if(maswrk.and.debug) then
               fperp = NEB_euclid_norm(n3,F_T(1:3,1:nat))
               fpara = NEB_euclid_norm(n3,Fs_pa(1:3,1:nat))
               write(iw,'(a,f20.10)') 'Debug: f-perpendi =',fperp
               write(iw,'(a,f20.10)') 'Debug: f-parallel =',fpara
c              write(iw,*) 'Debug: f'
c              do i=1,nat
c                 write(iw,'(3f18.8)') (f(j,i,ibead),j=1,3)
c                 end do
               endif
c
            enddo      ! loop of ibead...
         call DDI_sync(320123+icycle)
   
         !------------------------------------------
         !-- Convergence check
         f_sum = zero
         f_max = zero
         v_sum = zero
         v_max = zero
         if(maswrk.and.debug) write(iw,*) 'Debug: nbeads=',nbeads
         do ibead=2,(nbeads-1)
c
            if(maswrk.and.debug) write(iw,'(a,2i5)')
     *         'Debug: f,v, ibead,nbeads=',ibead,nbeads
c                                          ***** ******
c
            f_sum = f_sum + NEB_euclid_norm(n3, f(1:3,1:nat,ibead))
            v_sum = v_sum + v(ibead)
c
            if(f_max < NEB_euclid_norm(n3, f(1:3,1:nat,ibead))) then
               f_max = NEB_euclid_norm(n3, f(1:3,1:nat,ibead))
               end if
            if ( v_max < v(ibead) ) v_max = v(ibead)
            end do
c
c
         ! Debug
c        if(maswrk.and.debug) write(iw,'(i18,4f18.10)')
c    *      icycle, f_sum, f_max, v_sum, v_max
         if(maswrk) write(iw,'(a,i8,a,5f18.10)') 'icycle=',icycle,
     *      ': f,v =', f_sum, f_max, f_conv, v_sum, v_max
c                   -------------------------------------
c
         if ( f_sum < f_conv ) return
c        ****************************
c
         !------------------------------------------
         !-- Optimize
         if (icycle == 1) velo(1:3,1:nat,1:nbeads) = zero
         do ibead =2,(nbeads-1)
            if(maswrk.and.debug) write(iw,*) 'Debug: ibead=',ibead
            call NEB_quick_min(iw,n3, nbeads, x(1:3,1:nat,ibead), 
     *                  f(1:3,1:nat,ibead), dd(nat,nat),
     *                  velo(1:3,1:nat,ibead),
     *                  quickdt,ibead,maswrk,debug)
            end do
c        Caution: dd has nat*nat dimension, but only nat*3 area will be used.
c
c
c.@2019/03/05-SK
c
         ! Debug
         if(maswrk.and.debug) then
            write(iw,*) 'Debug: NEB_dbg_write'
            do ibead=1,nbeads
c              write(iw,'(i3,a,2i5)') nat,
c    *              '   --- Debug: icycle,ibead=',icycle,ibead
c                           ibead is always 11...?
c
c              call NEB_dbg_write_xyz(iw,ibead,nat,icycle,ian,X)
               call nebc3d(iw,ibead,nat,ian,x(1,1,ibead),
     *                     TOANGS,MASWRK)
               end do
            endif
         call DDI_sync(320124+icycle)
c.@@@    ------------------------
c        if(icycle.eq.1) then
c        if(icycle.ge.10) then
c        if(icycle.ge.100) then
c        if(icycle.ge.1000) then
c           if(maswrk.and.debug) then
c              write(iw,'(a)') ' '
c              write(iw,'(a,i5,a)') 'Debug: Coordinates after',icycle,
c    *                              ' cycle...'
c              do i=1,nbeads
c                 call nebc3d(iw,i,nat,ian,x(1,1,i),TOANGS,MASWRK)
c                 enddo
c              endif
c           call abrt
c           return
c           endif
c.@@@    ------------------------
         enddo ! end main cylces
      call DDI_sync(320125)
c
c     --------------
      if(maswrk.and.debug) then
         do i=1,nbeads
            call nebc3d(iw,i,nat,ian,x(1,1,i),TOANGS,MASWRK)
            enddo
         endif
c
      if(maswrk) write(iw,9900)
      call DDI_sync(320126)
 9900 format(/,'*** Exitin from NEB_idpp_interp routine ***',/)
c
      end subroutine NEB_idpp_interp
C*MODULE NEBPATH *DECK NEB_idpp_estimate
C>
C>    @brief    NEBPATH: IDPP estimation for moving atoms
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_idpp_estimate(iw,nat,nbeads, x, f, v, dc,di,
     *           maswrk,debug)
      ! The subroutine to evaluate IDPP and force of IDPP
      !*******************************************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      logical     maswrk, debug
      integer, intent(in) :: nat,nbeads
      double precision, intent(in)  :: x(1:3,1:nat,1:nbeads)

      double precision, intent(out) :: f(1:3,1:nat,1:nbeads)
c     double precision             :: ff(1:3,1:nat,1:nbeads)
c
      double precision, intent(out) :: v(1:nbeads)
      double precision, intent(out) :: dc(1:nat,1:nat)
      double precision, intent(in)  :: di(1:nat,1:nat,1:nbeads)

      double precision :: di4, di3
      double precision :: tmp, tmpvec(1:3), NEB_euclid_norm
      integer :: i, ii, j, ibead, icycle
      PARAMETER (zero=0.0d+00)
      PARAMETER (one=1.0d+00)
      PARAMETER (two=2.0d+00)
c
      ! nat       : number of atoms
        n3 = 3*nat
c
      ! nbeads    : number of beads
      ! nat       : number of atoms
      ! x = xx    : Coordinates of atoms in all beads
      ! di        : Distances between atoms in interpolated image
      !             di is calculated using linear interpolation based on the
      !             values of d1 and dn (described later).
      !             This value is an ideal value that is different from the
      !             actual molecular structure.
      ! di4       : di4 = di^4
      ! di3       : di3 = di^3
      ! d1        : Distances between atoms in 1st image
      ! dn        : Distances between atoms in last image
      ! dc        : Distances between atoms in computed image
      !             Unlike di, the dc indicates the distance of atoms corresponding to
      !             the structure of the molecule actually calculated.
      ! v         : Image dependent pair potential (IDPP)
      ! f = ff    : IDPP force (Negative gradient of IDPP)
c
      if(maswrk.and.debug) write(iw,9000)
 9000 format(/,'*** Getting into NEB_idpp_estimate routine...')
c   
      !------------------------------------------
      !-- Estimate energies(v) and forces(f)
c
      v(1:nbeads) = zero
      f(1:3,1:nat,1:nbeads) = zero
      if(maswrk.and.debug) write(iw,'(5f15.6)') v(1:nbeads)
c
      do ibead=2,(nbeads-1)
         ! Debug
         if(maswrk.and.debug) then
            write(iw,*) 'Debug: ibead=',ibead
            call NEBdstmtx(iw,nat,x(1,1,ibead),dc,maswrk,debug)
            write(iw,'(a,i3,2f15.6)') 'Debug: ibead=',ibead,
     *              di(4,1,ibead),dc(4,1)
            else
            call NEBdstmtx(iw,nat,x(1,1,ibead),dc,maswrk,.false.)
            endif
c
         do i = 1, nat
            do j = 1, nat
c              di4 = di(i,j,ibead)**4.0d0
c              di3 = di(i,j,ibead)**3.0d0
               di4 = di(i,j,ibead)**4
               di3 = di(i,j,ibead)**3
               if ( j /= i ) then
                  v(ibead) = v(ibead)
     *                     + ((di(i,j,ibead) - dc(i,j))**2) /di4
c
c                 ff(1:3,i,ibead) = ff(1:3,i,ibead)
c    *               + (two/di4-two/(di3*dc(i,j))) *tmpvec(1:3)
c
                  f(1:3,i,ibead) = f(1:3,i,ibead)
     *               + (two/di4-two/(di3*dc(i,j)))
     *                 *(x(1:3,i,ibead) - x(1:3,j,ibead))
c
                  end if
               end do
c
            end do
c
         v(ibead) = v(ibead)/two   ! get v
c
         ! Debug
         if(maswrk.and.debug) then
            write(iw,'(10f10.6)') (f(j,1,ibead),j=1,3)
            write(iw,'(10f10.6)') (f(j,2,ibead),j=1,3)
            write(iw,'(f15.6)') v(ibead)
            end if
c
         end do
c
c     ------------------------
      do ibead = 2, nbeads - 1
         if(maswrk.and.debug) write(iw,*) 'Debug: ibead=',ibead
         do i = 1, nat
            f(1:3,i,ibead) = -f(1:3,i,ibead)       ! get f
c           ii = 3*(i - 1)
c           f(ii+1:ii+3,ibead) = - ff(1:3,i,ibead) ! get f
            end do
         end do
c     ------------------------
c
      if(maswrk.and.debug) write(iw,9100)
 9100 format(/,'*** Exiting from NEB_idpp_estimate routine...')
c
      end subroutine NEB_idpp_estimate
C*MODULE NEBPATH *DECK NEB_dbg_write_xyz
C>
C>    @brief    NEBPATH: Debug writing of the coordinates
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_dbg_write_xyz(iw,ibead,natom,icycle,ian,X)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw,ibead, icycle, natom, ian(natom)
      double precision, intent(in) :: X(*)
      integer :: i
      character(len=128) :: file1
c
      !-- Write xyz file
      write(iw,'(i5,a,i5,a)') icycle, '.', ibead,'.xyz'
         write(iw,'(i5)') natom
         write(iw,'(2(a,i5))') ' cycle:', icycle, ', beads:', ibead
         do i = 1, natom
            write(iw,'(i2,3x,3f25.16)') ian(i), X(3*i-2:3*i)
         end do
      end subroutine NEB_dbg_write_xyz
C*MODULE NEBPATH *DECK NEB_dbg_3d_array
C>
C>    @brief    NEBPATH: Debug for 3D arrays
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_dbg_3d_array(iw,ibead,icycle,n,arr3d)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw,ibead, icycle, n
      double precision, intent(in) :: arr3d(:) ! arr3d(1:n)
      double precision :: NEB_euclid_norm
      integer :: i
      character(len=128) :: file1
c
         !-- Write xyz file
         write(iw,'(i0,a,i0,a)') icycle, '.', ibead, 
     *   '.dbg'
         write(iw,'(4a25)') 'X     ', 'Y     ', 'Z     ', 'Norm      '
         do i = 1, n/3
            write(iw,'(4f25.16)') arr3d(3*i-2:3*i), NEB_euclid_norm(3, 
     *      arr3d(3*i-2:3*i))
         end do
      end subroutine NEB_dbg_3d_array
C*MODULE NEBPATH *DECK NEB_dbg_1d_array
C>
C>    @brief    NEBPATH: Debug for 1D arrays
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_dbg_1d_array(iw,ibead, icycle, n, arr1d)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: iw,ibead, icycle, n
      double precision, intent(in) :: arr1d(:) ! arr1d(1:n)
      integer :: i
      character(len=128) :: file1
c
         !-- Write xyz file
         write(iw,'(i0,a,i0,a)') icycle, '.', ibead, 
     *   '.dbg'
         write(iw,'(a25)') 'X     '
         do i = 1, n
            write(iw,'(f25.16)') arr1d(i)
         end do
      end subroutine NEB_dbg_1d_array
C*MODULE NEBPATH *DECK NEB_quick_min
C>
C>    @brief    NEBPATH: Quick minization of gradients
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_quick_min(iw,n3,nbeads,Xi,Fi,uniFi,
     *               quickvelo,quickdt,beadsID,maswrk,debug)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer, intent(in) :: n3, nbeads, beadsID
      double precision, intent(inout) :: Xi(1:n3)
      double precision, intent(in)    :: Fi(1:n3)
      double precision, intent(inout) :: quickvelo(1:n3)
      double precision, intent(in)    :: quickdt
      integer :: i, j
      double precision :: uniFi(1:n3)
      double precision :: prod, mass, NEB_unit_vec
      double precision :: NEB_dot_prod2
      character(len=16) :: fname
      logical   maswrk, debug
   
      ! n3        : n3 = 3 * the number of atoms
      ! nbeads    : the number of beads
      ! beadsID   : Serial number of bead
      ! Xi        : Coordinates of atoms in all beads
      ! Fi        : Force on atoms (negative gradient)
      ! quickvelo : Velocity for quick-min
      ! quickdt   : Step size for quick-min
   
      !------------------------------------------
      !-- Initialize quickvelo (quickvelo = 0)
   
      !-- Normalize force
c
c     uniFi(1:n3) = NEB_unit_vec(n3, Fi(1:n3))
      uniFi(1:n3) = Fi(1:n3)
      call NEB_unit_vec2(n3,uniFi(1:n3))
c
      !-- Project the velocity in the direction of the force
      prod = NEB_dot_prod2(n3, quickvelo(1:n3), uniFi(1:n3))
c
      !-- Zero the velocity if it is antiparallel to the force
      if ( prod < 0.0d0 ) then
         quickvelo(1:n3) = 0.0d0
         if(maswrk.and.debug) print '(a,i0)',
     *      'NEB_quick_min: velocity was zero outed. beadsID = ',beadsID
         else
         do i = 1, n3
            quickvelo(i) = prod*uniFi(i)
            end do
         end if
      !-- Take an Euler step,
      do i = 1, n3
         quickvelo(i) = quickvelo(i) + quickdt * Fi(i)
         Xi(i) = Xi(i) + quickdt * quickvelo(i)
         end do
      if(maswrk.and.debug) write(iw,'(a,i3,f10.3)')
     *         'Debug: n3,quickdt=',n3,quickdt
   
      end subroutine NEB_quick_min
C*MODULE NEBPATH *DECK NEB_euclid_norm
C>
C>    @brief    NEBPATH: Normalization of vectors
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      !------------------------------------------
      function NEB_euclid_norm(n, vec)
      ! NEB_euclid_norm calculates the euclid norm of vec.
      !------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer :: i
      integer, intent(in) :: n
      double precision, intent(in) :: vec(n)
      double precision :: NEB_euclid_norm
c
         if (size(vec) /= n) then
            write(0,'(a)') 'NEB_euclid_norm input error'
         end if
c
         NEB_euclid_norm = 0.0d0
         do i = 1, n
            NEB_euclid_norm = NEB_euclid_norm + vec(i)**2.0d0
         end do
         NEB_euclid_norm = sqrt(NEB_euclid_norm)
c
      end function NEB_euclid_norm
C*MODULE NEBPATH *DECK NEB_unit_vec2
C>
C>    @brief    NEBPATH: Getting a unit vector
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      !------------------------------------------
      subroutine NEB_unit_vec2(n,vec)
      ! unitvec calculates the unit vector of vec.
      !------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      dimension  vec(1:n)
c
c     r = NEB_euclid_norm(n,vec(1:n))
c     vec(1:n) = vec(1:n)/r
c
      r = 0.0d+00
      do i=1,n
         r = r +vec(i)**2
         enddo
      r = sqrt(r)
      do i=1,n
         vec(i) = vec(i)/r
         enddo
c
      end subroutine NEB_unit_vec2
C*MODULE NEBPATH *DECK NEB_unit_vec
C>
C>    @brief    NEBPATH: Getting a unit vector
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      !------------------------------------------
      function NEB_unit_vec(n,vec)
      ! unitvec calculates the unit vector of vec.
      !------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer :: i
      integer, intent(in) :: n
      double precision, intent(in) :: vec(n)
      double precision :: NEB_unit_vec(1:n)
      double precision :: r
      double precision :: NEB_euclid_norm
c
         if (size(vec) /= n) then
            write(0,'(a)') 'Error of function unitvec'
         end if
         r = NEB_euclid_norm(n,vec)
         NEB_unit_vec(1:n) = vec(1:n)/r
      end function NEB_unit_vec
C --- ****************************************************
C*MODULE NEBPATH *DECK NEB_dot_prod2
      !------------------------------------------
      function NEB_dot_prod2(n, vec1, vec2)
      ! prod calculates dot product of row vector and column vector.
      ! Result is scalar.
      !------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      integer :: i
      integer, intent(in) :: n
      double precision, intent(in) :: vec1(1:n), vec2(1:n)
      double precision :: NEB_dot_prod2
c
         if (size(vec1) /= n .or. size(vec2) /= n) then
            write(0,'(a)') 'Error of function prod'
         end if
c
         NEB_dot_prod2 = 0.0d+00
         do i=1,n
            NEB_dot_prod2 = NEB_dot_prod2 + vec1(i)*vec2(i)
            end do
c
       end function NEB_dot_prod2
C*MODULE NEBPATH *DECK NEB_run1
C>
C>    @brief    NEBPATH: first gradient calculation at each bead
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_run1(iw,n3, L1, nbeads, X, V, Grad,f,
     *               irec, STORE, crdtol, toangs,
     *               restrt,maswrk,debug)
      use mx_limits, only: mxatm,mxao
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      integer, intent(in) :: n3, nbeads
      double precision, intent(in) :: X(1:n3,1:nbeads)
c
      double precision :: V(1:nbeads),Grad(1:nbeads)
      double precision :: f(1:n3,1:nbeads)
c
      integer :: irec(1:nbeads)
      double precision :: STORE(1:6*NAT+L1*L1*2)
c     X(LSTOREI) = Record number of the dictionary file      (NBEADS)
c     X(LSTORE)  = work area for Coord, Grad, and VEC        (3*NAT +3*NAT +NUM*NUM*2)
c
      double precision :: NEB_unit_vec, NEB_dot_prod2
      double precision :: NEB_euclid_norm
      logical      restrt, maswrk, dskwrk, debug, goparr, maswrkx
c
c     character*8  SCFTYP,CITYP
      data SCFUHF/8HUHF     /
      data CIGUGA/8HGUGA    /
c
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (ONE=1.0D+00)
      PARAMETER (two=2.0d+00)
c 
      PARAMETER (MXA3=3*MXATM)
      COMMON /MASSES/ ZMASS(MXATM)
c
c     COMMON /FUNCT / E,EG(MXA3)
c     COMMON /FUNCT / ENERGY,EGRAD(3,MXATM)
      COMMON /FUNCT / ENERGY,EGRAD(MXA3)
c     COMMON /GRAD  / DE(3,MXATM)
      COMMON /GRAD  / DE(MXA3)
c
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
c
c     COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /IOFILE/ idummy(5),IDAF,NAV,IODA(950)
c
c     COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /OUTPUT/ NPRINT,jdummy(5)
c
c     COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /RESTAR/ TIMLIM,IREST,kdummy(6)
c
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRKx
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOL,METHOD,NWDMP2,MEMPRI,MPPROP,
     *                NACORE,NBCORE,NOA,NOB,NORB,NBF,NOMIT,MOCPHF,MAXITC
c
      ! n3        : n3 = 3 * the number of atoms
      ! nbeads    : the number of beads
      ! X         : Coordinates of atoms in all beads
      ! V         : Energies of all beads
      ! Grad      : RMS gradients of all beads
      ! spring    : spring constant
c
c
      IF(MASWRK) WRITE(IW,9000)
      call DDI_sync(320130)
 9000 FORMAT(/,10X,30(1H-)/10X,'Entering NEB_run1 routine',/,
     *         10X,30(1H-),/)
c
c     L1 = NUM
      L3 = NUM*NUM
      nstore = (n3 + L3)*2
      n3x2 = n3*2
      istoreb = n3x2 + L3 +1
c
c     Record number for the dictionary file...
      do i=1,nbeads
         irec(i) = 700+i
         enddo
      if(maswrk.and.debug) then
         write(iw,'(a,5i8)') 'Debug: L1,L3,n3x2,istoreb,nstore =',
     *                        L1,L3,n3x2,istoreb,nstore
         write(iw,'(10i5)') iRec(1:nbeads)
         endif
c
c     Clear arrays...
      if(.not.restrt) then
         V(1:nbeads) = zero
         Grad(1:nbeads) = zero
         endif
c
c     For parallelization
      if(maswrk) then
         write(iw,'(a,L1)') 'Debug in NEB_run1: goparr =',goparr
         call ddi_nnode(nnode,mynode)
         if(goparr) write(iw,'(a,3i5)') 'Debug: nproc,nnode,mynode=',
     *              nproc,nnode,mynode
         endif
c.SK@20190315 ----------------
c
c     **********************************************
c     In order to generate the consistent orbitals
c     at each bead, single point calculations are
c     performed sequentially from the first bead
c     to the last bead.
c     Caution: the geometry at the last bead was
c     rotated for zero angular momentum caused by
c     the geometrical displacement between the first
c     and last beads.
c
c     It is necessary to generate $VEC at each bead squentially,
c     and to store them into the dictionary file.
c
c        V(ibead)        = energies
c        F(1:n3,1:ibead) = gradients
c        Grad(ibead)     = gradient RMS
c
c     *******************************
c     Energy & Gradients at each bead.
      do ibead=1,nbeads
c        if((ibead.gt.1).and.(.not.debug)) NPRINT =-5
c        if(debug) NPRINT =5
         if(debug) then
            NPRINT =5
            else
            if(ibead.gt.1) NPRINT =-5
            endif
c                       NPRINT =-5      ! minimal
c                       NPRINT = 3      ! 1e
c                       NPRINT = 5      ! scf
c                       NPRINT = 7      ! normal
c                       NPRINT = 9      ! maximum
c
         j0 = 0
         do i=1,nat
            do j=1,3
               j0 = j0 +1
               c(j,i) = x(j0,ibead)
               enddo
            enddo
         store(1:nstore) = zero
         ENERGY = zero
         EGRAD(1:n3) = zero
c
         if(maswrk) then
            write(iw,9020) ibead,nat,n3,num,L1,L3,ne
            do i=1,nat
c              WRITE(IW,9022) ANAM(I),BNAM(I),ZMASS(I),(C(j,i),j=1,3)
c    *                       ,Zan(i),Ian(i)
               WRITE(IW,9023) ANAM(I),BNAM(I),Zan(I),(C(j,i),j=1,3)
     *                       ,Zmass(i),Ian(i)
               enddo
c*          do i=1,n3
c*             write(iw,9024) (x(j,ibead),j=1,n3)
c*             enddo
            endif
         call DDI_sync(320132+ibead)
 9020 FORMAT(//,'*** ibead =',i3,'    Debug: nat,n3,num,L1,L3,ne=',6i8)
 9022 FORMAT(5x,a8,a2,1x,F10.4,3F18.10,f5.1,i5)
 9023 FORMAT(1x,a8,a2,1x,f5.1,3F18.10,f15.6,i5)
 9024 FORMAT(10x,3F18.10)
c
c.MWS[20190316 ---------------------------------------------
c     if(debug) then
c        if(maswrk) write(iw,*) 'I have reached NEB_run1'
c        call flshbf(iw)
c        call ddi_sync(15100)
c        if(maswrk) write(iw,*) 'all processes reached NEB_run1'
c        call flshbf(iw)
c        endif
c.MWS[20190316 ---------------------------------------------
c
c
         CALL ENERGX
c        ***********
         call DDI_sync(320133+ibead)
c
         if(ENERGY.eq.zero) then
            if(maswrk) write(iw,9030)
            call abrt
            endif
         call DDI_sync(320134+ibead)
 9030 format(/,'*** failed to obtain a total energy...')
c
         if(restrt) then
            if(v(ibead).eq.zero) then
c              This bead is newly added...
               V(ibead)=Energy
c
               else
               ediff = abs(energy-v(ibead))
               if(ediff.gt.0.00001d+00) then
c                            12345
                  if(maswrk) write(iw,9032) ibead,v(ibead),energy
                  call abrt
                  endif
               endif
            endif
 9032 format(/,'Error: the energy difference at the bead#',i3,
     *         ' too large: Energy =',2f20.10)
c
c                                    ----------------------------
         if(maswrk) write(iw,'(a)') 'Start a gradient calculation'
         call DDI_sync(320135+ibead)
c
c        IF (CITYP.EQ.GUGA) THEN
c        IF (CITYP.EQ.'GUGA    ') then
         IF (CITYP.EQ.CIGUGA) then
             CALL CIGRAD
             ELSE
             CALL HFGRAD
             END IF
         call DDI_sync(320136+ibead)
c
c        ------------------------------------------
c        Store the data into the dictionary file...
c        (ibead, Energy) C, EGRAD, VEC(alpha&beta)
c
         do i=1,n3
            STORE(i) = x(i,ibead)
            STORE(n3+i) =-EGRAD(i)
            enddo
         i0 = n3*2
c
c        alpha orbitals...
         call DAREAD(IDAF,IODA,STORE(i0+1),L3,15,0)
c        debug print...
c        CALL PUSQL(STORE(i0+1),iw,L1,L1)
c
c        beta orbitals, if necessary
         IF(SCFTYP.EQ.SCFUHF) THEN
            call DAREAD(IDAF,IODA,STORE(i0+istoreb),L3,19,0)
            endif
         call DDI_sync(320137+ibead)
c
c        double precision :: STORE(6*NAT+NUM*NUM*2)
c        double precision :: STORE(2*N3+L3*2)
         call DAWRIT(IDAF,IODA,STORE,nstore,iREC(ibead),0)
c        ---------------------------------------------- floating point
         if(maswrk) write(iw,9050) iREC(ibead),ibead,idaf
 9050 format(/,'*** Store the coordinates, gradients, and',
     *' vectors into the dictionary file.  iREC=',3i5)
c
         V(ibead) = ENERGY
         F(1:n3,ibead) =-EGRAD(1:n3)
c        Grad(ibead) = NEB_euclid_norm(n3,EGRAD(1:n3))
         Grad(ibead) = NEB_euclid_norm(n3,EGRAD(1:n3))/sqrt(float(n3))
c
         IF(MASWRK) then
            WRITE(IW,9100) ibead,V(ibead),Grad(ibead)
            ie = 0
            do i=1,nat
               is=ie+1
               ie=ie+3
               WRITE(IW,9102) i,(EGRAD(j),j=is,ie)
               enddo
            endif
         call DDI_sync(320138+ibead)
c
         enddo
c
      IF(MASWRK) then
         write(iw,9200)
         write(iw,9202) (i,V(i),Grad(i),i=1,nbeads)
         endif
c
      IF(MASWRK) WRITE(IW,9900)
      call DDI_sync(320139)
c
 9100 FORMAT(/,'#Bead        =',i5,
     *       /,'Energy       =',f20.10,' hartree',
     *       /,'Gradient RMS =',f20.10,' hartree/bohr')
 9102 FORMAT('#atom =',i5,'    EGRAD =',3f20.10)
 9200 FORMAT(/,'*** Summary ***',
     *//,' #Bead    Total E [au]       Gradient [au/bohr]')
 9202 FORMAT(i5,2f20.10)
 9900 FORMAT(/,10X,30(1H-)/10X,'Exiting NEB_run1 routine',/,
     *         10X,30(1H-),/)
c
      end subroutine NEB_run1
C*MODULE NEBPATH *DECK NEB_run
C>
C>    @brief    NEBPATH: Optimization of geometry at each bead
C>                       in order that the energy gradient perpendicular
C>                       to the reaction path becomes zero.
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_run(iw,n3,L1, nbeads, X, velo, V, Grad,
     *           tau, tau_plus, tau_minus, F, F_T, Fs_pa,
     *           dc,dd,di, irec, store, F_Trms,
     *           crdtol, toangs,opttol, spring, quickdt,
     *           iswitch, FTmax, maswrk,debug)
      use mx_limits, only: mxatm,mxao
c        call NEB_run(iw,n3, num, nbeads, X(LBEADS),
c    *            X(LVELOC), X(LENGY), X(LGRAD),
c    *            X(LVWORK),X(LTAU1),X(LTAU2),
c    *            X(LBFORC),X(LC1WORK),X(LC2WORK),
c    *            X(LD1WORK),X(LD2WORK),X(LBDIST),
c    *            X(LSTOREI),X(LSTORE),X(LFTrms),
c    *            crdtol,toangs,opttol,SPFORC, qdt,
c    *            iswitch,X(iFTmax),maswrk,debug)
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      integer, intent(in) :: n3, nbeads
      double precision, intent(inout) :: X(1:n3,1:nbeads)
      double precision, intent(inout) :: velo(1:n3,1:nbeads)
      double precision, intent(in)  :: spring, quickdt
      integer :: ibead, i, j, k
c
      double precision :: V(1:nbeads),Grad(1:nbeads)
c
      double precision :: tau(1:n3), tau_plus(1:n3), tau_minus(1:n3)
      double precision :: F(1:n3,1:nbeads), F_T(1:n3), Fs_pa(1:n3)
c
      double precision :: di(1:n3,1:nbeads)
      double precision :: dc(1:n3/3,1:n3/3), dd(1:n3/3,1:n3/3)
c
      integer :: irec(1:nbeads)
      double precision :: store(n3*2+L1*L1*2)
      double precision :: F_Trms(1:nbeads)
c     LFTrms = gradient RMS at each bead                (NBEADS)
c
      double precision :: NEB_unit_vec, NEB_dot_prod2
      double precision :: NEB_euclid_norm
c
c     character*8 SCFTYP, CITYP
c
      logical     maswrk, debug
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (ONE=1.0D+00)
      PARAMETER (two=2.0d+00)
   
      PARAMETER (MXA3=3*MXATM)
      COMMON /MASSES/ ZMASS(MXATM)
c
c     COMMON /FUNCT / E,EG(MXA3)
c     COMMON /FUNCT / ENERGY,EGRAD(3,MXATM)
      COMMON /FUNCT / ENERGY,EGRAD(MXA3)
c
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
c
c     COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /IOFILE/ idummy(5),IDAF,NAV,IODA(950)
c
c     COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /OUTPUT/ NPRINT,jdummy(5)
c
      data SCFUHF/8HUHF     /
      data CIGUGA/8HGUGA    /
c
      ! n3        : n3 = 3 * the number of atoms
      ! nbeads    : the number of beads
      ! X         : Coordinates of atoms in all beads
      ! velo      : velocity for using quick-min optimizer
      ! V         : Energies of all beads
      ! Grad      : RMS gradients of all beads
      ! spring  : spring constant
      ! tau       : tangent vector to the path
      ! tau_plus  : forward difference
      ! tau_minus : backward difference
      ! F         : force on atoms (negative gradient)
      ! F_T       : force in the direction perpendicular to the tangent vector
      ! Fs_pa     : spring force in the direction parallel to the tangent vector
c
c     L1 = NUM
      L3 = NUM*NUM
      nstore = (n3 + L3)*2
      n3x2 = n3*2
      istoreb = n3x2 + L3 +1
c
      IF(MASWRK) WRITE(IW,9000)
      call DDI_sync(320150)
 9000 FORMAT(/,10X,30(1H-)/10X,'Entering NEB_run routine',/,
     *         10X,30(1H-),/)
c
      IF(MASWRK.and.debug) then
         write(iw,9020) nbeads,L1,NUM,L3,nstore,istoreb,n3x2,n3
         do i=1,nbeads
            write(iw,9022) i,V(i),Grad(i)
            enddo
         endif
      call DDI_sync(320151)
 9020 FORMAT(/,'NBEADS,L1,NUM,L3,nstore,istoreb,n3x2,n3 =',8i8,
     * /,'*** Summary ***',
     *//,' #Bead    Total E                G RMS')
 9022 FORMAT(i5,2f20.10)
c
      !------------------------------------------
      !-- Intermediate images conditions
      !   Neb forces are calculated here.
      !   Foeces of end beads(1st and last beads) are not modified.
      do ibead = 2, nbeads-1
         if(maswrk.and.debug) write(iw,*) 'Debug: ibead=',ibead
c
         ! Calculation of tangent vectors along the path
         tau_plus(1:n3)  = X(1:n3,ibead+1) - X(1:n3,ibead)
         tau_minus(1:n3) = X(1:n3,ibead)   - X(1:n3,ibead-1)
c
         tau(1:n3) = tau_plus(1:n3) + tau_minus(1:n3)
c
c        tau(1:n3) = NEB_unit_vec(n3, tau(1:n3))
         call NEB_unit_vec2(n3,tau(1:n3))
         if(maswrk.and.debug) then
            write(iw,*) 'Debug: tau_1'
            write(iw,'(3f18.8)') tau(1:n3)
            endif
c
         ! Calculation of perpendicular forces
         ! These forces are perpendicular to the tangent vectors.
         F_T(1:n3) = F(1:n3,ibead)
     *        -NEB_dot_prod2(n3,F(1:n3,ibead),tau(1:n3))*tau(1:n3)
c
c        F_Tnorm(ibead) = NEB_euclid_norm(n3, F_T(1:n3))
         F_Trms(ibead) = NEB_euclid_norm(n3, F_T(1:n3))/sqrt(float(n3))
         if(maswrk.and.debug) then
            write(iw,'(a,f20.10)') 'Debug: F_T =', F_Trms(ibead)
            write(iw,'(3f18.8)') F_T(1:n3)
            endif
c
         ! Calculation of spring forces
         ! These forces are parallel to the tangent vectors.
         Fs_pa(1:n3) = tau_plus(1:n3) - tau_minus(1:n3)
         Fs_pa(1:n3) = spring
     *        *NEB_dot_prod2(n3,Fs_pa(1:n3),tau(1:n3)) *tau(1:n3)
c
         if(maswrk.and.debug) then
            write(iw,*) 'Debug: Fs_pa'
            write(iw,'(3f18.8)') Fs_pa(1:n3)
c           write(iw,'(a,2L1)') 'Debug: maswrk,debug =',maswrk,debug
            endif
c
         ! Calclation of resultant forces (NEB forces)
         ! Force values are overwritten here.
         F(1:n3,ibead) = F_T(1:n3) + Fs_pa(1:n3)
c
         if(maswrk.and.debug) then
            fperp = NEB_euclid_norm(n3,F_T(1:n3))
            fpara = NEB_euclid_norm(n3,Fs_pa(1:n3))
            write(iw,'(a,f20.10)') 'Debug: f-perpendi =',fperp
            write(iw,'(a,f20.10)') 'Debug: f-parallel =',fpara
            endif
         call DDI_sync(320152+ibead)
c
         end do
c
      if(maswrk.and.debug) then
c        write(iw,'(a,2L1)') 'Debug: maswrk,debug =',maswrk,debug
         write(iw,'(a,i5)') 'Debug: nbeads =',nbeads
         write(iw,'(a,f20.10)') 'Debug: opttol =',opttol
         write(iw,'(a,2f20.10)') 'Debug: E1&En =',V(1), V(nbeads)
         write(iw,'(a,2f20.10)')
     *        'Debug: G1&Gn =',Grad(1), Grad(nbeads)
         endif
c
      !------------------------------------------
      IF(MASWRK) then
         write(iw,9200)
         do i=1,nbeads
            write(iw,9206) i,V(i),Grad(i),F_Trms(i)
            enddo
         endif
      call DDI_sync(320153)
c
c     --------------------------------------------
      !-- Convergence check
c     do ibead=1,nbeads
      do ibead=2,(nbeads-1)
         if(F_Trms(ibead).gt.opttol) go to 100
         if(maswrk.and.debug) write(iw,9100) F_Trms(ibead),ibead
         enddo
      if(maswrk) then
         write(iw,9102)
         write(iw,9104) F_Trms(1:nbeads)
         endif
      iswitch = 3
      call DDI_sync(320154)
      return
  100 continue
 9100 format(/,'RMS of the perpendicular forces =',f20.10,
     *' at #Bead=',i3)
 9102 format(/,'*** Converged.     F_Trms =')
 9104 format(5f18.10)
c
      if(maswrk.and.debug) write(iw,'(a,2f20.10)')
     *   'Debug: E1&En =',V(1), V(nbeads)
c
      ichk = 0
      jchk = 0
      FTmax = zero
c     do ibead=1,nbeads
      do ibead=2,(nbeads-1)
         if(F_Trms(ibead).gt.(opttol*100.0d+00)) ichk=ichk+1
         if(F_Trms(ibead).gt.(opttol*10.0d+00))  jchk=jchk+1
         if(F_Trms(ibead).gt.FTmax) FTmax=F_Trms(ibead)
         enddo
      if(ichk.eq.0) iswitch=1
      if((ichk.eq.0).and.(jchk.eq.0)) iswitch=2
      call DDI_sync(320155)
c
      !------------------------------------------
      !-- Optimization
      !   Since end beads(1st and last beads) are already optimized,
      !   end beads are not optimized here.
      do ibead=2,(nbeads-1)
         if(maswrk.and.debug) write(iw,*) 'Debug: ibead=',ibead
c
         if(maswrk.and.debug) call nebc3d(iw,ibead,nat,ian,x(1,ibead),
     *                             TOANGS,MASWRK)
c
c.original
c        call quick_min(n3, nbeads, X(1:n3,ibead), F(1:n3,ibead),
c    *   velo(1:n3,ibead), quickdt, ibead)
c
c        uniFi(1:3,1:nat) = dd(1:nat,1:nat)
         call NEB_quick_min(iw,n3, nbeads, x(1:n3,ibead), 
     *        f(1:n3,ibead), dd(1:nat,1:nat), velo(1:n3,ibead),
     *        quickdt,ibead,maswrk,debug)
c
         enddo
      call DDI_sync(320156)
c
c
      if(maswrk.and.debug) write(iw,'(a,2f20.10)')
     *            'Debug: E1&En =',V(1), V(nbeads)
c
c     NEBanglr...
c     do ibead=1,(nbeads-2)    ! need to do for the final bead...
      do ibead=1,(nbeads-1)
         call NEBanglr(iw,nat,anam,bnam,ian,Zmass,
     *        X(1,ibead),X(1,ibead+1),crdtol,
     *        tau_plus,tau_minus,dc,dd,
     *        toangs,MASWRK,debug)
c
         enddo
      call DDI_sync(320157)
c
      if(maswrk.and.debug) then
         write(iw,'(a,2f20.10)') 'Debug: E1&En =',V(1), V(nbeads)
c
         do ibead=1,nbeads
            call nebc3d(iw,ibead,nat,ian,x(1,ibead),
     *                      TOANGS,MASWRK)
            enddo
c
c        ************************
c        if(ibead.eq.2) then
c        if(ibead.gt.2) then
c           write(iw,*) 'Debug: stop here on 2019/03/08...'
c           call abrt
c           endif
c        ************************
         endif
      call DDI_sync(320158)
c
      if(maswrk.and.debug) write(iw,'(a,2f20.10)')
     *   'Debug: E1&En =',V(1), V(nbeads)
c
c     Energy & gradients
      do ibead=2,(nbeads-1)
c
c        if((ibead.gt.1).and.(.not.debug)) NPRINT =-5
c        if(.not.debug) NPRINT =-5
         if(debug) then
            NPRINT =5
            else
            NPRINT =-5
            endif
c                       NPRINT =-5      ! minimal
c                       NPRINT = 3      ! 1e
c                       NPRINT = 5      ! scf
c                       NPRINT = 7      ! normal
c                       NPRINT = 9      ! maximum
c
c        Load the information of the current bead...
         j0 = 0
         do i=1,nat
            do j=1,3
               j0 = j0 +1
               c(j,i) = x(j0,ibead)
               enddo
            enddo
         store(1:nstore) = zero
         ENERGY = zero
         EGRAD(1:n3) = zero
c
c        double precision :: STORE(6*NAT+NUM*NUM*2)
c        double precision :: STORE(2*N3+L3*2)
         call DAREAD(IDAF,IODA,STORE,nstore,iREC(ibead),0)
         if(maswrk) write(iw,'(a,i3)')
     *      'Read the previous data at #BEAD=',ibead
c
c        alpha orbitals...
         call DAWRIT(IDAF,IODA,STORE(n3x2+1),L3,15,0)
         if(maswrk) write(iw,'(a,i3)')
     *      'Store the alpha orbitals at #BEAD=',ibead
c        debug print...
c        CALL PUSQL(STORE(n3x2+1),iw,L1,L1)
c
c        beta orbitals, if necessary
         IF(SCFTYP.EQ.SCFUHF) THEN
            call DAWRIT(IDAF,IODA,STORE(n3x2+istoreb),L3,19,0)
            if(maswrk) write(iw,'(a,i3)')
     *         'Store the beta orbitals at #BEAD=',ibead
            endif
c
         if(maswrk) then
            write(iw,9120) ibead,nat,n3,num,ne
            do i=1,nat
c              WRITE(IW,9122) ANAM(I),BNAM(I),ZMASS(I),(C(j,i),j=1,3)
c    *                       ,Zan(i),Ian(i)
               WRITE(IW,9123) ANAM(I),BNAM(I),Zan(I),(C(j,i),j=1,3),
     *                        Zmass(i),Ian(i)
               enddo
c           do i=1,n3
c              write(iw,9124) (x(j,ibead),j=1,n3)
c              enddo
            endif
         call DDI_sync(320159+ibead)
 9120 FORMAT(//,'*** ibead =',i3,'    Debug: nat,n3,num,ne=',4i5)
 9122 FORMAT(5x,a8,a2,1x,F10.4,3F18.10,f5.1,i5)
 9123 FORMAT(1x,a8,a2,1x,F5.1,3F18.10,f15.6,i5)
 9124 FORMAT(10x,3F18.10)
c
         if(maswrk) write(iw,'(a,i3)')
     *      'Start a single point calculation'
         CALL ENERGX
c
         if(ENERGY.eq.zero) then
            if(maswrk) write(iw,9030)
            call abrt
            endif
         call DDI_sync(320160+ibead)
 9030 format(/,'*** failed to obtain a total energy...')
c
         if(maswrk) write(iw,'(a,i3)') 'Start a gradient calculation'
c        IF (CITYP.EQ.GUGA) THEN
c        IF (CITYP.EQ.'GUGA    ') then
         IF (CITYP.EQ.CIGUGA) then
             CALL CIGRAD
             ELSE
             CALL HFGRAD
             END IF
         call DDI_sync(320161+ibead)
c
c        ------------------------------------------
c        Restore the data into the dictionary file...
c        (ibead, Energy) C, EGRAD, VEC(alpha&beta)
c
         do i=1,n3
            STORE(i) = x(i,ibead)
            STORE(n3+i) =-EGRAD(i)
            enddo
c
c        alpha orbitals...
         call DAREAD(IDAF,IODA,STORE(n3x2+1),L3,15,0)
         if(maswrk) write(iw,'(a,i3)')
     *      'Read the alpha orbitals at #BEAD=',ibead
c        debug print...
c        CALL PUSQL(STORE(n3x2+1),iw,L1,L1)
c
c        beta orbitals, if necessary
         IF(SCFTYP.EQ.SCFUHF) THEN
            call DAREAD(IDAF,IODA,STORE(n3x2+istoreb),L3,19,0)
            if(maswrk) write(iw,'(a,i3)')
     *         'Read the beta orbitals at #BEAD=',ibead
            endif
c
         call DAWRIT(IDAF,IODA,STORE,nstore,iREC(ibead),0)
c        ------------------------------------------
         if(maswrk) write(iw,'(a,i3)')
     *      'Store the information at #BEAD=',ibead
         call DDI_sync(320162+ibead)
c
         V(ibead) = ENERGY
         F(1:n3,ibead) =-EGRAD(1:n3)
         Grad(ibead) = NEB_euclid_norm(n3,EGRAD(1:n3))
c
         IF(MASWRK) then
            WRITE(IW,9202) ibead,V(ibead),Grad(ibead),F_Trms(ibead)
            ie = 0
            do i=1,nat
               is=ie+1
               ie=ie+3
               WRITE(IW,9204) i,(EGRAD(j),j=is,ie)
               enddo
            endif
c
         if(maswrk.and.debug) write(iw,*) '15: n3 =',n3
         enddo
      call DDI_sync(320163)
c
      IF(MASWRK) then
         write(iw,9200)
         do i=1,nbeads
            write(iw,9206) i,V(i),Grad(i),F_Trms(i)
            enddo
         endif
 9200 FORMAT(/,'*** Summary ***',
     *//,' #Bead    Total E [au]',11x,'G RMS [au/bohr]',5x,
     *   'Perpendicular gradient [au/bohr]')
 9202 FORMAT('ibead=',i5,'  V, G, and F_T =',3f20.10)
 9204 FORMAT('#atom ',i5,'  EGRAD =',3f20.10)
 9206 FORMAT(i5,3f20.10)
c
c   
      IF(MASWRK) WRITE(IW,9900)
      call DDI_sync(320164)
 9900 FORMAT(/,10X,30(1H-)/10X,'Exiting NEB_run routine',/,
     *         10X,30(1H-),/)
c
      end subroutine NEB_run
C*MODULE NEBPATH *DECK NEB_autokcal
C>
C>    @brief    NEBPATH: Print out the results at every beads
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      subroutine NEB_autokcal(iw,nat,nbeads,zmass,X,
     *               V,Grad,F_Trms,FTmax,jcycle,
     *               toangs,tokcal,maswrk,debug)
c
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      dimension  zmass(1:nat),X(1:3,1:nat,nbeads)
      dimension  FTmax(1:jcycle)
      dimension  V(1:nbeads), Grad(1:nbeads), F_Trms(1:nbeads)
c                hartree      hartree/bohr    hartree/bohr
c                kcal/mol     kcal/mol/A      kcal/mol/A
c
      PARAMETER (zero=0.0d+00)
      logical    maswrk, debug
c
      IF(.not.MASWRK) return
      write(iw,9200)
      stotal = zero
      do ibead=1,nbeads
c
         Ekcal = (V(ibead)-V(1))*tokcal
         Gkcal = Grad(ibead)*tokcal/toangs
         Fkcal = F_Trms(ibead)*tokcal/toangs
c
c        The distance between two beads...
         rbeads = zero
         if(ibead.gt.1) then
            do i=1,nat
               ribead = zero
               do j=1,3
                  ribead = ribead +zmass(i)
     *              *(X(j,i,ibead)-X(j,i,ibead-1))**2
                  enddo
               rbeads = rbeads +sqrt(ribead)
               enddo
            rbeads = rbeads/float(nat)
            stotal = stotal +rbeads
            endif
c
c        write(iw,9202) ibead,stotal,rbeads,
c    *         Ekcal,Grad(ibead),F_Trms(ibead)
         write(iw,9202) ibead,stotal,rbeads,Ekcal,Gkcal,Fkcal
         enddo
      write(iw,9400) jcycle
      write(iw,9402) (j,FTmax(j),j=2,jcycle)
      return
 9200 FORMAT(/,'*** Summary ***',
     *//,' #Bead   Dist & dD [sqrt(amu)*bohr]   dE (kcal/mol)',5x,
     *   'G RMS (kcal/mol/A)',6x,'Perpendicular GRMS(kcal/mol/A)')
 9202 FORMAT(i5,2f12.6,6x,f12.3,2(f18.6,5x))
 9400 FORMAT(/,'Profile of the perpendicular gradient...  jcycle=',i8)
 9402 FORMAT(3('(',i5,f12.6,')  '))
c
      end subroutine NEB_autokcal
C*MODULE NEBPATH *DECK NEBrestart
C>
C>    @brief    NEBPATH: Print out the restart data
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE NEBrestart(ir,iw,nat,zan,nbeads,X,V,Grad,
     *              velo,maswrk,debug)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      double precision :: zan(1:nat)
      double precision :: X(1:3,1:nat,1:nbeads)
      double precision :: V(1:nbeads), Grad(1:nbeads)
      double precision :: velo(1:3,1:nat,1:nbeads)
      logical    maswrk,debug
c
      character*80  xline
      character*8   keywrd
c
      PARAMETER (keywrd=' $BEADSX')
c                       12345678
    1 format(a80)
c
      rewind ir
  100 continue
      read(ir,1,err=900,end=900) xline
      call nebcapital(xline)
      if(xline(1:8).ne.keywrd) go to 100
c
      do ibead=1,nbeads
         read(ir,1,err=900,end=900) xline
         read(xline(8:12),*) jbead
         if(jbead.ne.ibead) then
            if(maswrk) write(iw,9100) jbead,ibead
            call abrt
            endif
         read(xline(22:41),*) V(ibead)
         read(xline(54:73),*) Grad(ibead)
c
c        Coordinates...
         do i=1,nat
            read(ir,1,err=900,end=900) xline
            read(xline(11:80),*) zzan,(x(j,i,ibead),j=1,3)
            if(zzan.ne.zan(i)) then
               if(maswrk) write(iw,9200) ibead,nat,zan(i),zzan
               call abrt
               endif
            enddo
c
c        Velocities...
         read(ir,1,err=900,end=900) xline
         do i=1,nat
            read(ir,1,err=900,end=900) xline
            read(xline(11:80),*) zzan,(velo(j,i,ibead),j=1,3)
            if(zzan.ne.zan(i)) then
               if(maswrk) write(iw,9200) ibead,nat,zan(i),zzan
               call abrt
               endif
            enddo
         enddo
      return
 9100 format(/,'Error: jbead, ibead =',2i5)
 9200 format(/,'Error: ibead,nat,zan,zzan =',2i5,2f10.3)
c              1         2         3         4         5         6         7
c     123456789012345678901234567890123456789012345678901234567890123456789012345
c     #bead =12345, Energy=12345678901234567890, Grad RMS =12345678901234567890
c     xxxxxxxxxx 1234567890,3f18.10)
c
  900 continue
      if(maswrk) write(iw,9900) keywrd
      call abrt
 9900 format(/,'Error: reach the end of the input file...',
     *       /,'       could not file the keyword=',a8)
c
      end subroutine NEBrestart
C*MODULE NEBPATH *DECK NEBtrajectory
C>
C>    @brief    NEBPATH: Print out the coordinates and their velocities
C>
C>    @author   Nozomi Sawada, Mamoru Haruta, Toshio Asada, Shiro Koseki
C>              Osaka Prefecture University, Japan
C
      SUBROUTINE NEBtrajectory(iw,nat,anam,bnam,zan,
     *              nbeads,X,V,Grad,velo,icycle,maswrk,debug)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c
      double precision :: anam(1:nat),bnam(1:nat)
      double precision :: zan(1:nat)
      double precision :: X(1:3,1:nat,1:nbeads)
      double precision :: V(1:nbeads), Grad(1:nbeads)
      double precision :: CV(1:3)
      double precision :: velo(1:3,1:nat,1:nbeads)
      logical    maswrk,debug
      PARAMETER (ZERO=0.0D+00)
      PARAMETER (ONE=1.0D+00)
      PARAMETER (two=2.0d+00)
c
      if(.not.maswrk) return
      write(iw,9000) icycle
      do ibead=1,nbeads
         write(iw,9010) ibead,V(ibead),Grad(ibead)
c
c        Coordinates...
         do i=1,nat
            write(iw,9020) anam(i),bnam(i),zan(i),
     *           (x(j,i,ibead),j=1,3)
            enddo
c
c        Velocities...
         write(iw,9040)
         do i=1,nat
            write(iw,9022) anam(i),bnam(i),zan(i),
     *           (velo(j,i,ibead),j=1,3)
            enddo
         enddo
      write(iw,9900)
c
 9000 format(/,'*** Caution: all data are in atomic unit.',
     *       /,' $BEADSX          icycle=',i8)
 9010 format('#bead =',i5,', Energy=',f20.10,
     *', Grad RMS=',f20.12)
 9020 format(a8,a2,1x,f10.4,3f18.10)
 9022 format(a8,a2,1x,f10.4,3e18.8)
 9040 format('*** Velocities of atoms ---')
 9900 format(' $END')
c
c     a structgure between the neighboring beads...
      if(iw.eq.6) return
      write(iw,9100)
      izero = 0
      do ibead=1,(nbeads-1)
         write(iw,9110) ibead,(ibead+1)
         write(iw,9010) izero,zero,zero
         do i=1,nat
            CV(1:3) = (X(1:3,i,ibead)+X(1:3,i,ibead+1))/two
            write(iw,9020) anam(i),bnam(i),zan(i),(CV(j),j=1,3)
            enddo
         enddo
 9110 format('*** This line must be deleted.  #ibead=',i3,' -',i3,
     *     /,'    And you have to renumber #bead in your input.')
 9100 format('*** the followings are the coordinates between',
     *       ' the neighboring beads.',
     *     /,'    You may like to add some of these into $BEADSX',
     *       ' and change NBEADS.')
c
      end subroutine NEBtrajectory
