! Protecting macro for compilers which does not support OpenMP 4.0
!#define OMPSIMD (_OPENMP >= 201307)

!> @brief Helper functions and data blocks needed
!> to compute one-electron integrals and their derivatives
!
!> @author   Vladimir Mironov
!
!> @todo
!> - Unify interfaces
!> - Cleanup redundant subroutines
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
MODULE mod_1e_primitives
 USE prec, ONLY: fp
 USE mx_limits, ONLY: MXSH, MXGTOT, MXATM, MXAO
 USE mod_nosp_basis, ONLY: basis_set, nosp_basis
 USE mod_gauss_hermite, ONLY: doQuadGaussHermite
 USE mod_shell_tools, ONLY: shell_t, shpair_t
 IMPLICIT NONE

 INTEGER :: iii

 INTEGER, PARAMETER :: &
!   !< Number of Cartesian Gaussian basis set functions in a shell for different angular momentums
!   NBFS(7) = [((iii+1)*(iii)/2, iii = 1, 7)], &

   !< 1 + power of X in Cartesian Gaussian basis functions
   IJX(28,7) = reshape([ &
      [1,                                                              (0, iii =  2, 28)], &
      [2, 1, 1,                                                        (0, iii =  4, 28)], &
      [3, 1, 1, 2, 2, 1,                                               (0, iii =  7, 28)], &
      [4, 1, 1, 3, 3, 2, 1, 2, 1, 2,                                   (0, iii = 11, 28)], &
      [5, 1, 1, 4, 4, 2, 1, 2, 1, 3, 3, 1, 3, 2, 2,                    (0, iii = 16, 28)], &
      [6, 1, 1, 5, 5, 2, 1, 2, 1, 4, 4, 3, 1, 3, 1, 4, 2, 2, 3, 3, 2,  (0, iii = 22, 28)], &
      [7, 1, 1, 6, 6, 2, 1, 2, 1, 5, 5, 3, 1, 3, 1, 5, 2, 2, 4, 4, 1, 4, 4, 3, 2, 3, 2, 3] &
      ], [28,7]), &

   !< 1 + power of Y in Cartesian Gaussian basis functions
   IJY(28,7) = reshape([ &
      [1,                                                              (0, iii =  2, 28)], &
      [1, 2, 1,                                                        (0, iii =  4, 28)], &
      [1, 3, 1, 2, 1, 2,                                               (0, iii =  7, 28)], &
      [1, 4, 1, 2, 1, 3, 3, 1, 2, 2,                                   (0, iii = 11, 28)], &
      [1, 5, 1, 2, 1, 4, 4, 1, 2, 3, 1, 3, 2, 3, 2,                    (0, iii = 16, 28)], &
      [1, 6, 1, 2, 1, 5, 5, 1, 2, 3, 1, 4, 4, 1, 3, 2, 4, 2, 3, 2, 3,  (0, iii = 22, 28)], &
      [1, 7, 1, 2, 1, 6, 6, 1, 2, 3, 1, 5, 5, 1, 3, 2, 5, 2, 4, 1, 4, 3, 2, 4, 4, 2, 3, 3] &
      ], [28,7]), &

   !< 1 + power of Z in Cartesian Gaussian basis functions
   IJZ(28,7) = reshape([ &
      [1,                                                              (0, iii =  2, 28)], &
      [1, 1, 2,                                                        (0, iii =  4, 28)], &
      [1, 1, 3, 1, 2, 2,                                               (0, iii =  7, 28)], &
      [1, 1, 4, 1, 2, 1, 2, 3, 3, 2,                                   (0, iii = 11, 28)], &
      [1, 1, 5, 1, 2, 1, 2, 4, 4, 1, 3, 3, 2, 2, 3,                    (0, iii = 16, 28)], &
      [1, 1, 6, 1, 2, 1, 2, 5, 5, 1, 3, 1, 3, 4, 4, 2, 2, 4, 2, 3, 3,  (0, iii = 22, 28)], &
      [1, 1, 7, 1, 2, 1, 2, 6, 6, 1, 3, 1, 3, 5, 5, 2, 2, 5, 1, 4, 4, 2, 3, 2, 3, 4, 4, 3] &
      ], [28,7])

 REAL(KIND=fp), PARAMETER :: PI     = 3.14159265358979324_fp !< \f$ \Pi \f$ constant
 REAL(KIND=fp), PARAMETER :: TWOPI  = 6.28318530717958648_fp !< \f$ 2\cdot\Pi \f$ constant
 REAL(KIND=fp), PARAMETER :: SQRTPI = 1.77245385090551602_fp !< \f$ 2\cdot\Pi \f$ constant
 REAL(KIND=fp), PARAMETER :: PI212  = 1.12837916709551257_fp !< \f$ 2\cdot\Pi^{-1/2} \f$
 REAL(KIND=fp), PARAMETER :: ZERO = 0.0_fp


!REAL(KIND=fp) :: xyzin(8,7,3,7)
 REAL(KIND=fp) :: xyzin(14,7,3,7)
!$omp threadprivate(xyzin)
!dir$ attributes align : 64 :: xyzin

 REAL(KIND=fp) :: dxyzc(5,5,3,5) ! to support higher angular momentums -> (8,7,3,7)
!$omp threadprivate(dxyzc)
!dir$ attributes align : 64 :: dxyzc

 REAL(KIND=fp) :: xyzovl(8,7,3)
!$omp threadprivate(xyzovl)
!dir$ attributes align : 64 :: xyzovl

 REAL(KIND=fp) :: xyzkin(8,7,3) ! padding bytes
!$omp threadprivate(xyzkin)
!dir$ attributes align : 64 :: xyzkin

 REAL(KIND=fp) :: xyzlz(8,7,2)
!$omp threadprivate(xyzlz)
!dir$ attributes align : 64 :: xyzlz

 REAL(KIND=fp) :: &
        !ovl_int(6,7,3), kin_int(6,5,3), &
        !ovl_der(5,5,3), kin_der(5,5,3) &
        ovl_int(5,8,3), kin_int(5,6,3), &
        ovl_der(5,5,3), kin_der(5,5,3)
!dir$ attributes align : 64 :: ovl_int, kin_int
!dir$ attributes align : 64 :: ovl_der, kin_der
!$omp threadprivate(ovl_int, kin_int, ovl_der, kin_der)

 PRIVATE

! PUBLIC IJX, IJY, IJZ

 PUBLIC comp_coulomb_int1_prim
 PUBLIC comp_kin_ovl_int1_prim
 PUBLIC comp_lz_int1_prim
 PUBLIC comp_fmoesp_int1_prim
 PUBLIC comp_coulomb_dampch_int1_prim
 PUBLIC comp_coulpot_prim
 PUBLIC comp_coulomb_der1
 PUBLIC comp_coulomb_helfeyder1
 PUBLIC comp_kinetic_der1

 PUBLIC update_triang_matrix
 PUBLIC density_ordered
 PUBLIC density_unordered

CONTAINS


!--------------------------------------------------------------------------------
!       ONE-ELECTRON INTEGRALS CALCULATION (PRIMITIVE GAUSSIANS)
!--------------------------------------------------------------------------------

!> @brief Compute primitive block of overlap and kinetic energy 1e integrals
!> @param[in]       cp          shell pair data
!> @param[in]       id          current pair of primitives
!> @param[in]       dokinetic   if `.FALSE.` compute only overlap integrals
!> @param[inout]    sblk        block of 1e overlap integrals
!> @param[inout]    tblk        block of 1e kinetic energy integrals
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE comp_kin_ovl_int1_prim(cp, id, dokinetic, sblk, tblk)
!dir$ attributes inline :: comp_kin_ovl_int1_prim

    TYPE(shpair_t), INTENT(IN)  :: cp
    INTEGER, INTENT(IN) :: id
    LOGICAL, INTENT(IN)   :: dokinetic
    REAL(KIND=fp), CONTIGUOUS,   INTENT(INOUT) :: sblk(:), tblk(:)

    INTEGER :: i, j, nx, ny, nz, mx, my, mz, jmax, ij
    REAL(KIND=fp) :: ovl, kinx, kiny, kinz, kin
!dir$ assume_aligned sblk : 64
!dir$ assume_aligned tblk : 64
!dir$ assume_aligned xyzkin : 64
!dir$ assume_aligned xyzovl : 64

    jmax = cp%jang
    IF (dokinetic) jmax = cp%jang+2

    ASSOCIATE (pp => cp%p(id))
    CALL overlap_xyz(cp%ri, cp%rj, pp%r, pp%aa1, cp%iang, jmax, xyzovl)

    IF (dokinetic) CALL kinetic_xyz_j(xyzkin, xyzovl, cp%iang, cp%jang, pp%aj)

    ij = 0
    jmax = cp%jnao
    DO i = 1, cp%inao
        nx = IJX(i,cp%iang)
        ny = IJY(i,cp%iang)
        nz = IJZ(i,cp%iang)
        IF (cp%iandj) jmax = i
        DO j = 1, jmax
            mx = IJX(j,cp%jang)
            my = IJY(j,cp%jang)
            mz = IJZ(j,cp%jang)
            ij = ij+1

            ovl = xyzovl(mx,nx,1)*xyzovl(my,ny,2)*xyzovl(mz,nz,3)
            sblk(ij) = sblk(ij) + pp%expfac*ovl

            IF (dokinetic) THEN
                kinx = xyzkin(mx,nx,1)*xyzovl(my,ny,2)*xyzovl(mz,nz,3)
                kiny = xyzovl(mx,nx,1)*xyzkin(my,ny,2)*xyzovl(mz,nz,3)
                kinz = xyzovl(mx,nx,1)*xyzovl(my,ny,2)*xyzkin(mz,nz,3)
                kin  = kinx + kiny + kinz
                tblk(ij) =  tblk(ij) + pp%expfac*kin
            END IF
        END DO

    END DO

    END ASSOCIATE

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Compute primitive block of 1e Coulomb atraction integrals
!> @param[in]       cp          shell pair data
!> @param[in]       id          current pair of primitives
!> @param[in]       c           coordinates of the charged particle
!> @param[in]       znuc        particle charge
!> @param[inout]    vblk        block of 1e Coulomb integrals
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE comp_coulomb_int1_prim(cp, id, c, znuc, vblk)
!dir$ attributes inline :: comp_coulomb_int1_prim

    TYPE(shpair_t), INTENT(IN)    :: cp
    INTEGER, INTENT(IN)   :: id
    REAL(KIND=fp), INTENT(IN)   :: c(3), znuc
    REAL(KIND=fp), CONTIGUOUS,   INTENT(INOUT) :: vblk(:)

    COMMON /ROOT  / xx,u(13),w(13),nroots
      REAL(KIND=fp) :: xx,u,w
      INTEGER :: nroots
!$omp threadprivate(/ROOT  /)

    INTEGER :: i, j, ij, jmax, nx, ny, nz, mx, my, mz
    REAL(KIND=fp) :: dum, dij
!dir$ assume_aligned xyzin : 64
!dir$ assume_aligned vblk : 64

    ASSOCIATE (pp => cp%p(id), &
               iang => cp%iang, jang => cp%jang, &
               inao => cp%inao, jnao => cp%jnao)

    xx = pp%aa* sum((pp%r-c)**2)
    CALL QGaussRys(cp, id, c, znuc, xyzin)

    dij = pp%expfac*TWOPI*pp%aa1
    ij = 0
    jmax = jnao
    DO i = 1, inao
        nx = IJX(i,iang)
        ny = IJY(i,iang)
        nz = IJZ(i,iang)
        IF (cp%iandj) jmax = i
        DO j = 1, jmax
            mx = IJX(j,jang)
            my = IJY(j,jang)
            mz = IJZ(j,jang)
            ij = ij+1

            dum = dij * sum(  xyzin(mx,nx,1,1:nroots) &
                            * xyzin(my,ny,2,1:nroots) &
                            * xyzin(mz,nz,3,1:nroots) )

            vblk(ij) = vblk(ij) + dum
        END DO
    END DO
    END ASSOCIATE

END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Compute primitive block of 1e Coulomb ESP integrals in FMO method
!> @param[in]       cp          shell pair data
!> @param[in]       id          current pair of primitives
!> @param[in]       c           coordinates of the charged particle
!> @param[in]       znuc        particle charge
!> @param[in]       fracv       FMO nuclear attraction scaling factor
!> @param[in]       fracesp     FMO ESP scaling factor
!> @param[inout]    vblk        block of 1e Coulomb integrals
!> @param[inout]    zblk        block of 1e Coulomb ESP integrals
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE comp_fmoesp_int1_prim(cp, id, c, znuc, fracv, fracesp, vblk, zblk)
!dir$ attributes forceinline :: comp_fmoesp_int1_prim

    TYPE(shpair_t), INTENT(IN)    :: cp
    INTEGER, INTENT(IN)   :: id
    REAL(KIND=fp),   INTENT(IN)    :: c(3), znuc
    REAL(KIND=fp),   INTENT(IN)    :: fracv, fracesp
    REAL(KIND=fp), CONTIGUOUS,   INTENT(INOUT) :: vblk(:), zblk(:)

    COMMON /ROOT  / xx,u(13),w(13),nroots
      REAL(KIND=fp) :: xx,u,w
      INTEGER :: nroots
!$omp threadprivate(/ROOT  /)

    INTEGER :: i, j, ij, jmax, nx, ny, nz, mx, my, mz
    REAL(KIND=fp) :: dum, dij
!dir$ assume_aligned xyzin : 64
!dir$ assume_aligned vblk : 64
!dir$ assume_aligned zblk : 64


    ASSOCIATE (pp => cp%p(id), &
               iang => cp%iang, jang => cp%jang, &
               inao => cp%inao, jnao => cp%jnao)

    xx = pp%aa*sum((pp%r-c)**2)
    CALL QGaussRys(cp, id, c, znuc, xyzin)

    dij = pp%expfac*TWOPI*pp%aa1
    ij = 0
    jmax = jnao
    DO i = 1, inao
        nx = IJX(i,iang)
        ny = IJY(i,iang)
        nz = IJZ(i,iang)
        IF (cp%iandj) jmax = i
        DO j = 1, jmax
            mx = IJX(j,jang)
            my = IJY(j,jang)
            mz = IJZ(j,jang)
            ij = ij+1

            dum = dij * sum( xyzin(mx,nx,1,1:nroots)*xyzin(my,ny,2,1:nroots)*xyzin(mz,nz,3,1:nroots) )

            vblk(ij) = vblk(ij) + dum * fracv
            zblk(ij) = zblk(ij) + dum * fracesp
        END DO
    END DO
    END ASSOCIATE

END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Subtract damping function term from ESP block
!> @details Compute one-electron Coulomb integrals with the damping function:
!>  \f$ |r-r_C|^{-1} (1 - \beta e^{-\alpha(r-r_C)^2}) \f$
!>  Only the part \f$ - |r-r_C|^{-1} \beta e^{-\alpha(r-r_C)^2}) \f$ is computed here;
!>  the other part is regular Coulomb potential computed elsewhere
!> @param[in]       cp          shell pair data
!> @param[in]       id          current pair of primitives
!> @param[in]       alpha       dumping exponent
!> @param[in]       beta        dumping function scaling factor
!> @param[in]       c           coordinates of the charged particle
!> @param[in]       znuc        particle charge
!> @param[inout]    vblk        block of 1e Coulomb integrals
!> @note the original implementaion: DAMPCH subroutine in fmoint.src
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE comp_coulomb_dampch_int1_prim(cp,id,alpha,beta,c,znuc,vblk)
!dir$ attributes forceinline :: comp_coulomb_dampch_int1_prim

    TYPE(shpair_t), INTENT(IN) :: cp
    INTEGER, INTENT(IN) :: id
    REAL(KIND=fp), INTENT(IN) :: alpha, beta, c(3), znuc
    REAL(KIND=fp), CONTIGUOUS, INTENT(INOUT) :: vblk(:)

    COMMON /ROOT  / xx,u(13),w(13),nroots
    REAL(KIND=fp) :: xx,u,w
    INTEGER :: nroots
!$omp threadprivate(/ROOT  /)

    REAL(KIND=fp) :: dumgij, pcsq, prei, dum, dum1
    INTEGER :: i, j, ij, nx, ny, nz, mx, my, mz, jmax
!dir$ assume_aligned xyzin : 64
!dir$ assume_aligned vblk : 64

    ASSOCIATE (pp => cp%p(id), &
               iang => cp%iang, jang => cp%jang, &
               inao => cp%inao, jnao => cp%jnao)

    pcsq = pp%aa*sum((pp%r-c)**2)
    xx = pp%aa*pcsq/(pp%aa+alpha)
!   scale DIJ with 1/(aa+alpha) factor
    dumgij = TWOPI/(pp%aa+alpha)
    !IF (aa==ZERO .AND. alpha==ZERO) dumgij = 1.0
    prei = exp(-(pcsq-xx))
    !prei = exp(-alpha*pcsq/(aa+alpha))

    dum1 = dumgij*pp%expfac*prei*beta

    CALL QGaussRys_damp(cp,id,c,znuc,alpha,xyzin)

    ij = 0
    jmax = jnao
    DO i = 1, inao
        nx = IJX(i,iang)
        ny = IJY(i,iang)
        nz = IJZ(i,iang)
        IF (cp%iandj) jmax = i
        DO j = 1, jmax
            mx = IJX(j,jang)
            my = IJY(j,jang)
            mz = IJZ(j,jang)
            ij = ij+1
            dum = sum( xyzin(mx,nx,1,1:nroots)*xyzin(my,ny,2,1:nroots)*xyzin(mz,nz,3,1:nroots) )
            vblk(ij) = vblk(ij) - dum1*dum
        END DO
    END DO
    END ASSOCIATE

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Compute sum of 1e Coulomb integrals over primitive shell pair
!> @param[in]       cp          shell pair data
!> @param[in]       id          current pair of primitives
!> @param[in]       c           coordinates of the charged particle
!> @param[in]       den         normalized density matrix block
!> @param[inout]    vsum        sum of Coulomb integrals over pair of primitives
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Oct, 2018_ Initial release
!
 SUBROUTINE comp_coulpot_prim(cp, id, c, den, vsum)
!dir$ attributes inline :: comp_coulpot_prim

    TYPE(shpair_t), INTENT(IN)    :: cp
    INTEGER, INTENT(IN) :: id
    REAL(KIND=fp),    INTENT(IN)    :: c(3)
    REAL(KIND=fp),    INTENT(IN)    :: den(:)
    REAL(KIND=fp),    INTENT(INOUT) :: vsum

    COMMON /ROOT  / xx,u(13),w(13),nroots
      REAL(KIND=fp) :: xx,u,w
      INTEGER :: nroots
!$omp threadprivate(/ROOT  /)

    REAL(KIND=fp) :: tmp
    INTEGER :: i, j, ij, jmax, nx, ny, nz, mx, my, mz
!dir$ assume_aligned xyzin : 64

    ASSOCIATE (pp => cp%p(id), &
               iang => cp%iang, jang => cp%jang, &
               inao => cp%inao, jnao => cp%jnao)

    xx = pp%aa*sum((pp%r-c)**2)
    CALL QGaussRys(cp, id, c, 1.0_fp, xyzin)

    tmp = 0.0
    ij = 0
    jmax = jnao
    DO i = 1, inao
        nx = IJX(i,iang)
        ny = IJY(i,iang)
        nz = IJZ(i,iang)
        IF (cp%iandj) jmax = i
        DO j = 1, jmax
            mx = IJX(j,jang)
            my = IJY(j,jang)
            mz = IJZ(j,jang)
            ij = ij+1

            tmp = tmp + den(ij) * sum( xyzin(mx,nx,1,1:nroots)*xyzin(my,ny,2,1:nroots)*xyzin(mz,nz,3,1:nroots) )

        END DO
    END DO

    vsum = vsum + tmp*pp%expfac*TWOPI*pp%aa1

    END ASSOCIATE

END SUBROUTINE


!--------------------------------------------------------------------------------

!> @brief Compute primitive block of 1e Coulomb ESP integrals in FMO method
!> @param[in]       cp          shell pair data
!> @param[in]       id          current pair of primitives
!> @param[inout]    zblk        block of 1e Lz-integrals
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE comp_lz_int1_prim(cp, id, zblk)
!dir$ attributes inline :: int1_lz_prim

    TYPE(shpair_t), INTENT(IN)    :: cp
    INTEGER, INTENT(IN) :: id
    REAL(KIND=fp), CONTIGUOUS,    INTENT(INOUT) :: zblk(:)

    INTEGER :: i, j, ij, nx, ny, nz, mx, my, mz, jmax

    REAL(KIND=fp) :: dum2
!dir$ assume_aligned zblk : 64
!dir$ assume_aligned xyzovl : 64
!dir$ assume_aligned xyzlz : 64

    ASSOCIATE (pp => cp%p(id), &
               iang => cp%iang, jang => cp%jang, &
               inao => cp%inao, jnao => cp%jnao)

    CALL overlap_xyz(cp%ri, cp%rj, pp%r, pp%aa1, iang, jang+1, xyzovl)

    ! j-1
    xyzlz(1,1:iang,1:2) = 0.0
    DO j = 2, jang
        xyzlz(j,1:iang,1:2) = (j-1) * xyzovl(j-1,1:iang,1:2)
    END DO

    ij = 0
    jmax = jnao
    DO i = 1, inao
        nx = IJX(i,iang)
        ny = IJY(i,iang)
        nz = IJZ(i,iang)
        IF (cp%iandj) jmax = i
        DO j = 1, jmax
            mx = IJX(j,jang)
            my = IJY(j,jang)
            mz = IJZ(j,jang)

            ij = ij+1

            dum2 = xyzovl(mx+1,nx,1)*xyzlz(my,ny,2) - xyzlz(mx,nx,1)*xyzovl(my+1,ny,2)
            zblk(ij) = zblk(ij) + pp%expfac*dum2*xyzovl(mz,nz,3)
        END DO
    END DO
    END ASSOCIATE

END SUBROUTINE

!--------------------------------------------------------------------------------
!       ONE-ELECTRON DERIVATIVES CALCULATION (PRIMITIVE GAUSSIANS)
!--------------------------------------------------------------------------------

!> @brief Compute 1e kinetic contribution to the gradient
!> @param[in]       cp          shell pair data
!> @param[in]       dij         density matrix block
!> @param[inout]    de          dimension(3), contribution to gradient
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE comp_kinetic_der1(cp, dij, de)
!dir$ attributes inline :: comp_kinetic_der1
    TYPE(shpair_t), INTENT(IN) :: cp
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN) :: dij(:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(INOUT) :: de(:)

    REAL(KIND=fp) :: der(3), de_loc(3)
    INTEGER :: i, j, k, ij, ix, iy, iz, jx, jy, jz

    DO k = 1, cp%numpairs
    ASSOCIATE (pp => cp%p(k), &
               iang => cp%iang, jang => cp%jang, &
               inao => cp%inao, jnao => cp%jnao)
    ! compute overlap [i+3|j]
    CALL overlap_xyz(cp%ri, cp%rj, pp%r, pp%aa1, iang+3, jang, ovl_int)

    ! compute 1D kinetic [i+1|j]
    CALL kinetic_xyz_i(kin_int,ovl_int,iang+1,jang,pp%ai)

    ! compute 1D overlap derivatives [i|j]
    CALL der_kinovl_xyz(ovl_der,ovl_int,iang,jang,pp%ai)

    ! compute 1D kinetic derivatives [i|j]
    CALL der_kinovl_xyz(kin_der,kin_int,iang,jang,pp%ai)

    ! assemble 3D K.E. derivatives from 1D integrals and derivatives
    de_loc = 0.0
    ij = 0
    DO i = 1, inao
        ix = IJX(i,iang)
        iy = IJY(i,iang)
        iz = IJZ(i,iang)
        DO j = 1, jnao
            jx = IJX(j,jang)
            jy = IJY(j,jang)
            jz = IJZ(j,jang)
            der(1) = kin_der(jx,ix,1) * ovl_int(jy,iy,2) * ovl_int(jz,iz,3) + &
                     ovl_der(jx,ix,1) * kin_int(jy,iy,2) * ovl_int(jz,iz,3) + &
                     ovl_der(jx,ix,1) * ovl_int(jy,iy,2) * kin_int(jz,iz,3)
            der(2) = kin_int(jx,ix,1) * ovl_der(jy,iy,2) * ovl_int(jz,iz,3) + &
                     ovl_int(jx,ix,1) * kin_der(jy,iy,2) * ovl_int(jz,iz,3) + &
                     ovl_int(jx,ix,1) * ovl_der(jy,iy,2) * kin_int(jz,iz,3)
            der(3) = kin_int(jx,ix,1) * ovl_int(jy,iy,2) * ovl_der(jz,iz,3) + &
                     ovl_int(jx,ix,1) * kin_int(jy,iy,2) * ovl_der(jz,iz,3) + &
                     ovl_int(jx,ix,1) * ovl_int(jy,iy,2) * kin_der(jz,iz,3)
            ij = ij+1
            de_loc = de_loc + der*dij(ij)
        END DO
    END DO
    ! add scaled contribution to gradient
    de = de + de_loc*pp%expfac
    END ASSOCIATE
    END DO
 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Compute 1e Coulomb contribution to the gradient (v.r.t. shifts of
!>  shell's centers)
!> @param[in]       cp          shell pair data
!> @param[in]       c           coordinates of the charged particle
!> @param[in]       znuc        particle charge
!> @param[in]       dij         density matrix block
!> @param[inout]    dernuc      dimension(3), contribution to gradient
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE comp_coulomb_der1(cp, c, znuc, dij, dernuc)
!dir$ attributes inline :: comp_coulomb_der1
    TYPE(shpair_t), INTENT(IN) :: cp
    REAL(KIND=fp), INTENT(IN) :: c(3), znuc
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN) :: dij(:)
    REAL(KIND=fp), INTENT(OUT) :: dernuc(3)

    COMMON /ROOT  / xx,u(13),w(13),nroots
      REAL(KIND=fp) :: xx,u,w
      INTEGER :: nroots
!$omp threadprivate(/ROOT  /)

    REAL(KIND=fp) :: der(3), fac, detmp(3)
    INTEGER :: id, i, j, ij, ix, iy, iz, jx, jy, jz
!dir$ assume_aligned xyzin : 64
!dir$ assume_aligned dxyzc : 64

    dernuc = 0.0

    DO id = 1, cp%numpairs

        ASSOCIATE (pp => cp%p(id), &
                   iang => cp%iang, jang => cp%jang, &
                   inao => cp%inao, jnao => cp%jnao)

        xx = pp%aa*sum((pp%r-c)**2)

        CALL QGaussRys(cp, id, c, znuc, xyzin, 1)

        CALL der_coul_xyz(dxyzc,xyzin,iang,jang,pp%ai,nroots)

        fac = pp%expfac*TWOPI*pp%aa1

        detmp = 0.0

        ij = 0
        DO i = 1, inao
            ix = IJX(i,iang)
            iy = IJY(i,iang)
            iz = IJZ(i,iang)
            DO j = 1, jnao
                jx = IJX(j,jang)
                jy = IJY(j,jang)
                jz = IJZ(j,jang)

                der(1) = sum( dxyzc(jx,ix,1,1:nroots)*xyzin(jy,iy,2,1:nroots)*xyzin(jz,iz,3,1:nroots) )
                der(2) = sum( xyzin(jx,ix,1,1:nroots)*dxyzc(jy,iy,2,1:nroots)*xyzin(jz,iz,3,1:nroots) )
                der(3) = sum( xyzin(jx,ix,1,1:nroots)*xyzin(jy,iy,2,1:nroots)*dxyzc(jz,iz,3,1:nroots) )

                ij = ij+1

                detmp = detmp + der*dij(ij)

             END DO
        END DO
        dernuc = dernuc + detmp*fac
        END ASSOCIATE
    END DO

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Compute 1e Hellmann-Feynman contribution to the gradient
!> @param[in]       cp          shell pair data
!> @param[in]       c           coordinates of the charged particle
!> @param[in]       znuc        particle charge
!> @param[in]       dij         density matrix block
!> @param[inout]    derhf       dimension(3), contribution to gradient
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE comp_coulomb_helfeyder1(cp, c, znuc, dij, derhf)
!dir$ attributes inline :: comp_coulomb_helfeyder1
    TYPE(shpair_t), INTENT(IN) :: cp
    REAL(KIND=fp), INTENT(IN) :: c(3), znuc
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN) :: dij(:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT) :: derhf(:)

    COMMON /ROOT  / xx,u(13),w(13),nroots
      REAL(KIND=fp) :: xx,u,w
      INTEGER :: nroots
!$omp threadprivate(/ROOT  /)

    REAL(KIND=fp) :: ric(3)
    REAL(KIND=fp) :: der(3), fac
    INTEGER :: id, i, j, ij, ix, iy, iz, jx, jy, jz, jmax
!dir$ assume_aligned xyzin : 64
!dir$ assume_aligned dxyzc : 64

    derhf = 0.0

    ric = cp%ri(:3) - c(:3)

    DO id = 1, cp%numpairs

        ASSOCIATE (pp => cp%p(id), &
                   iang => cp%iang, jang => cp%jang, &
                   inao => cp%inao, jnao => cp%jnao)

        xx = pp%aa*sum((pp%r-c)**2)

        fac = pp%expfac*TWOPI*2

        CALL DQGaussRys(cp, id, c, znuc, xyzin)

        CALL der_helfey_xyz(dxyzc,xyzin,iang,jang,ric,nroots)

        jmax = jnao

        ij = 0
        DO i = 1, inao
            ix = IJX(i,iang)
            iy = IJY(i,iang)
            iz = IJZ(i,iang)
            IF (cp%iandj) jmax = i
            DO j = 1, jmax
                jx = IJX(j,jang)
                jy = IJY(j,jang)
                jz = IJZ(j,jang)

                der(1) = sum(dxyzc(jx,ix,1,1:nroots)*xyzin(jy,iy,2,1:nroots)*xyzin(jz,iz,3,1:nroots))
                der(2) = sum(xyzin(jx,ix,1,1:nroots)*dxyzc(jy,iy,2,1:nroots)*xyzin(jz,iz,3,1:nroots))
                der(3) = sum(xyzin(jx,ix,1,1:nroots)*xyzin(jy,iy,2,1:nroots)*dxyzc(jz,iz,3,1:nroots))

                ij = ij+1

                derhf = derhf + der*dij(ij)*fac
             END DO
        END DO
        END ASSOCIATE
    END DO

 END SUBROUTINE

!--------------------------------------------------------------------------------
!       K.E. AND OVERLAP 1D INTEGRALS
!--------------------------------------------------------------------------------

!> @brief Compute 1D overlap integrals
!> @details Return block of 1D integrals, dimensions: (Lj,Li,XYZ)
!> @param[in]       ri          coordinates of first shell center
!> @param[in]       rj          coordinates of second shell center
!> @param[in]       rij         coordinates of shell-pair center of charge
!> @param[in]       aa1         inverse total exponent
!> @param[in]       li          max angular momentum for the first shell center
!> @param[in]       lj          max angular momentum for the second shell center
!> @param[inout]    xyzovl      block of 1D overlap integrals
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE overlap_xyz(ri, rj, rij, aa1, li, lj, xyzovl)
!dir$ attributes forceinline :: overlap_xyz

    REAL(KIND=fp), CONTIGUOUS, INTENT(IN)   :: ri(:), rj(:), rij(:)
    REAL(KIND=fp), INTENT(IN)   :: aa1
    INTEGER, INTENT(IN)   :: li, lj
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT)  :: xyzovl(:,:,:)

    INTEGER :: i, j
    REAL(KIND=fp) :: taa, oint(3)

    taa = sqrt(aa1)

    DO i = 1, li
        DO j = 1, lj
            CALL doQuadGaussHermite(oint, taa, rij(:3), &
                                    ri(:3), rj(:3), i, j)
            xyzovl(j,i,:) = oint*taa
        END DO
    END DO

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Kinetic energy integrals, recursion over first shell
!> @details Compute K.E.I. from overlap integrals using recurrence
!>  over first shell
!> @param[out] xyzt 1D kinetic energy integrals
!> @param[in]  xyzs 1D overlap integrals
!> @param[in]  ni   number of points for the 1st shell quad.
!> @param[in]  nj   number of points for the 2nd shell quad.
!> @param[in]  ai   first shell exponent
!> @author   Vladimir Mironov
!
!> @note Before running this routine, first you need to
!>  compute overlap integrals for angular momentums (Li+2, Lj)
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE kinetic_xyz_i(xyzt,xyzs,ni,nj,ai)
!dir$ attributes forceinline :: kinetic_xyz_i
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT) :: xyzt(:,:,:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN)  :: xyzs(:,:,:)
    REAL(KIND=fp), INTENT(IN)  :: ai
    INTEGER, INTENT(IN) :: ni, nj

    INTEGER :: i
    REAL(KIND=fp) :: fact1, fact2

    xyzt(1:nj,1,:) = (xyzs(1:nj,1,:) - 2*ai*xyzs(1:nj,3,:))*ai

    IF (ni==1) RETURN

    xyzt(1:nj,2,:) = (xyzs(1:nj,2,:)*3.0_fp - 2*ai*xyzs(1:nj,4,:))*ai

    IF (ni==2) RETURN

    DO i = 3, ni
      fact1 = 2*i-1
      fact2 = real((i-1)*(i-2)/2,fp)
      xyzt(1:nj,i,:) = (xyzs(1:nj,i,:)*fact1 - 2*ai*xyzs(1:nj,i+2,:))*ai - xyzs(1:nj,i-2,:)*fact2
    END DO

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Kinetic energy integrals, recursion over second shell
!> @details Compute K.E.I. from overlap integrals using recurrence
!>  over second shell
!> @param[out] xyzt 1D kinetic energy integrals
!> @param[in]  xyzs 1D overlap integrals
!> @param[in]  ni   number of points for the 1st shell quad.
!> @param[in]  nj   number of points for the 2nd shell quad.
!> @param[in]  aj   second shell exponent
!> @author   Vladimir Mironov
!
!> @note Before running this routine, first you need to
!>  compute overlap integrals for angular momentums (Li+2, Lj)
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE kinetic_xyz_j(xyzt,xyzs,ni,nj,aj)
!dir$ attributes forceinline :: kinetic_xyz_j
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT) :: xyzt(:,:,:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN)  :: xyzs(:,:,:)
    REAL(KIND=fp), INTENT(IN)  :: aj
    INTEGER, INTENT(IN) :: ni, nj

    INTEGER :: j
    REAL(KIND=fp) :: fact1, fact2

    xyzt(1,1:ni,:) = (xyzs(1,1:ni,:) - 2*aj*xyzs(3,1:ni,:))*aj

    IF (nj==1) RETURN

    xyzt(2,1:ni,:) = (xyzs(2,1:ni,:)*3.0_fp - 2*aj*xyzs(4,1:ni,:))*aj

    IF (nj==2) RETURN

    DO j = 3, nj
      fact1 = 2*j-1
      fact2 = real((j-1)*(j-2)/2,fp)
      xyzt(j,1:ni,:) = (xyzs(j,1:ni,:)*fact1 - 2*aj*xyzs(j+2,1:ni,:))*aj - xyzs(j-2,1:ni,:)*fact2
    END DO

 END SUBROUTINE

!--------------------------------------------------------------------------------
!       DERIVATIVE CODE 1D INTEGRALS
!--------------------------------------------------------------------------------

!> @brief Compute derivatives of 1D Coulomb integrals v.r.t. shifts of shell centers
!> @details Derivatives are computed using following equation:
!>  \f$ D(L_i,L_j) = 2\alpha_i I(L_i+1,L_j) - L_i I(L_i-1,L_j) \f$
!> @param[out] dxyzdi    1D Coulomb integral derivatives (dims: (Lj,Li,XYZ,NRoots)
!> @param[in]  xyzin     1D Coulomb integrals (dims: (Lj,Li,XYZ,NRoots)
!> @param[in]  lit       angular momentum of the 1st shell + 1
!> @param[in]  ljt       angular momentum of the 2nd shell + 1
!> @param[in]  ai        exponent of the first shell
!> @param[in]  nroots    number of roots in Gauss-Rys quadrature
!> @author   Vladimir Mironov
!
!> @note based on DERI from grd1.src
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE der_coul_xyz(dxyzdi,xyzin,lit,ljt,ai,nroots)
!dir$ attributes forceinline :: der_coul_xyz
    REAL(KIND=fp), INTENT(IN) ::  ai
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN) ::  xyzin(:,:,:,:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT) :: dxyzdi(:,:,:,:)
    INTEGER, INTENT(IN) :: lit, ljt, nroots

    INTEGER :: i
!dir$ assume_aligned xyzin : 64
!dir$ assume_aligned dxyzdi : 64

    dxyzdi(1:ljt,1:lit,1:3,1:nroots) = 2*ai * xyzin(1:ljt,2:lit+1,1:3,1:nroots)

    DO i = 2, lit
        dxyzdi(1:ljt,i,1:3,1:nroots) = dxyzdi(1:ljt,i,1:3,1:nroots) - (i-1)*xyzin(1:ljt,i-1,1:3,1:nroots)
    END DO

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Compute derivatives of 1D Coulomb integrals v.r.t. shifts of the nuclei
!>  (Hellman-Feynman term)
!>  Derivatives are computed using following equation:
!>  \f$ D(L_i,L_j) = I(L_i+1,L_j) - (r_i - r_c) I(L_i,L_j) \f$
!> @param[out] dxyzdc    1D Coulomb integral derivatives (dims: (Lj,Li,XYZ,NRoots)
!> @param[in]  xyzin     1D Coulomb integrals (dims: (Lj,Li,XYZ,NRoots)
!> @param[in]  lit       angular momentum of the 1st shell + 1
!> @param[in]  ljt       angular momentum of the 2nd shell + 1
!> @param[in]  ric       (Ri-Rij)xyz
!> @param[in]  nroots    number of roots in Gauss-Rys quadrature
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE der_helfey_xyz(dxyzdc,xyzin,lit,ljt,ric,nroots)
!dir$ attributes forceinline :: der_helfey_xyz
    REAL(KIND=fp), INTENT(IN) ::  ric(3)
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN) ::  xyzin(:,:,:,:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT) :: dxyzdc(:,:,:,:)
    INTEGER, INTENT(IN) :: lit, ljt, nroots
!dir$ assume_aligned xyzin : 64

    dxyzdc(1:ljt,1:lit,1,1:nroots) = xyzin(1:ljt,2:lit+1,1,1:nroots) + ric(1)*xyzin(1:ljt,1:lit,1,1:nroots)
    dxyzdc(1:ljt,1:lit,2,1:nroots) = xyzin(1:ljt,2:lit+1,2,1:nroots) + ric(2)*xyzin(1:ljt,1:lit,2,1:nroots)
    dxyzdc(1:ljt,1:lit,3,1:nroots) = xyzin(1:ljt,2:lit+1,3,1:nroots) + ric(3)*xyzin(1:ljt,1:lit,3,1:nroots)

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief 1e overlap and kinetic energy integrals differentiation
!> @param[out] dxyz 1D derivatives
!> @param[in]  xyz  1D integrals
!> @param[in]  lit  angular momentum of the 1st shell + 1
!> @param[in]  ljt  angular momentum of the 2nd shell + 1
!> @param[in]  ai   exponent of the first shell
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE der_kinovl_xyz(dxyz,xyz,lit,ljt,ai)
!dir$ attributes forceinline :: der_kinovl_xyz
    REAL(KIND=fp), INTENT(IN) ::  ai
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN) ::  xyz(:,:,:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT) :: dxyz(:,:,:)
    INTEGER, INTENT(IN) :: lit, ljt
    INTEGER :: i

    dxyz(1:ljt,1:lit,:) =  2*ai * xyz(1:ljt,2:lit+1,:)

    !IF (lit==1) RETURN

    DO i = 2, lit
        dxyz(1:ljt,i,:) = dxyz(1:ljt,i,:) - (i-1)*xyz(1:ljt,i-1,:)
    END DO

 END SUBROUTINE

!--------------------------------------------------------------------------------
!       GAUSS-RYS QUADRATURE RELATED ROUTINES
!--------------------------------------------------------------------------------

!> @brief Compute 1D integrals for 1e Coulomb integrals
!> @details In this implementation 1D integrals at Rys abscissae are
!>  computed using VRR and HRR recurrences
!> @note The common factor for the integral block is \f$ 2\Pi \f$
!> @param[in]  cp       shell pair data
!> @param[in]  id       current pair of primitives
!> @param[in]  c        coordinates of the charged particle
!> @param[in]  znuc     charge of the particle
!> @param[out] xyzin    array of 1D integrals
!> @param[in]  igrd     [opt] flag indicating that integral derivatives are needed
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE QGaussRys(cp, id, c, znuc, xyzin, igrd)
!dir$ attributes forceinline :: QGaussRys
    TYPE(shpair_t), INTENT(IN) :: cp
    INTEGER, INTENT(IN) :: id
    REAL(KIND=fp), INTENT(IN)   :: c(3), znuc
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT)  :: xyzin(0:,0:,:,:)
    INTEGER, INTENT(IN), OPTIONAL :: igrd

    COMMON /ROOT  / xx,u(13),w(13),nroots
      REAL(KIND=fp) :: xx,u,w
      INTEGER :: nroots
!$omp threadprivate(/ROOT  /)

    INTEGER :: ni, nj, k, igrd1
    REAL(KIND=fp) :: ww, tt
    REAL(KIND=fp) :: b, d(3), dij(3)
!dir$ assume_aligned xyzin : 64

    igrd1 = 0
    IF (present(igrd)) igrd1 = igrd

    SELECT CASE (nroots)
        CASE (:3) ; CALL rt123
        CASE (4)  ; CALL root4
        CASE (5)  ; CALL root5
        CASE (6:) ; CALL root6
    END SELECT

    ASSOCIATE (pp => cp%p(id), iang => cp%iang, jang => cp%jang)
    DO k = 1, nroots
        ww = w(k)*znuc
        tt = u(k)/(1.0+u(k))
        b = 0.5*(1.0-tt)/pp%aa
        d = (pp%r-cp%rj) - tt*(pp%r-c)
        dij = cp%rj - cp%ri

        xyzin(0,0,1,k) = 1.0
        xyzin(0,0,2,k) = 1.0
        xyzin(0,0,3,k) = ww

        xyzin(1,0,1,k) = d(1)
        xyzin(1,0,2,k) = d(2)
        xyzin(1,0,3,k) = d(3)*ww

        ! VRR (Lj+1,0) <- Rpj*(Lj,0) + Lj*b*(Lj-1,0)
        DO nj = 2, (iang+jang-2)+igrd1
            xyzin(nj,0,:,k) = d*xyzin(nj-1,0,:,k) + (nj-1)*b*xyzin(nj-2,0,:,k)
        END DO

        ! HRR (Lj,Li+1) <- (Lj+1,Li) + Rij*(Lj,Li)
        nj = (iang+jang-2)+igrd1
        DO ni = 1, (iang-1)+igrd1
            nj = nj-1
            xyzin(0:nj,ni,1,k) = xyzin(1:nj+1,ni-1,1,k) + dij(1)*xyzin(0:nj,ni-1,1,k)
            xyzin(0:nj,ni,2,k) = xyzin(1:nj+1,ni-1,2,k) + dij(2)*xyzin(0:nj,ni-1,2,k)
            xyzin(0:nj,ni,3,k) = xyzin(1:nj+1,ni-1,3,k) + dij(3)*xyzin(0:nj,ni-1,3,k)
        END DO

    END DO
    END ASSOCIATE

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Compute 1D Coulomb integrals with Gaussian damping
!> @details Compute 1D integrals for the modified Coulomb potential:
!>  \f$ |r-r_C|^{-1}\cdot e^{-\alpha(r-r_C)^2} \f$
!> @param[in]  cp       shell pair data
!> @param[in]  id       current pair of primitives
!> @param[in]  c        coordinates of the charged particle
!> @param[in]  znuc     charge of the particle
!> @param[in]  alpha    dumping exponent
!> @param[out] xyzin    array of 1D integrals
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
 SUBROUTINE QGaussRys_damp(cp,id,c,znuc,alpha,xyzin)
!dir$ attributes forceinline :: QGaussRys_damp
    TYPE(shpair_t), INTENT(IN) :: cp
    INTEGER, INTENT(IN) :: id
    REAL(KIND=fp), INTENT(IN)   :: alpha, c(3), znuc
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT)  :: xyzin(0:,0:,:,:)

    COMMON /ROOT  / xx,u(13),w(13),nroots
    REAL(KIND=fp) :: xx,u,w
    INTEGER :: nroots
!$omp threadprivate(/ROOT  /)

    INTEGER :: ni, nj
    INTEGER :: k
    REAL(KIND=fp) :: ww, tt
    REAL(KIND=fp) :: b, d(3), dij(3)
!dir$ assume_aligned xyzin : 64

    SELECT CASE (nroots)
        CASE (:3) ; CALL rt123
        CASE (4)  ; CALL root4
        CASE (5)  ; CALL root5
        CASE (6:) ; CALL root6
    END SELECT

    ASSOCIATE (pp => cp%p(id), iang => cp%iang, jang => cp%jang)

    DO k = 1, nroots
        ww = w(k)*znuc
        tt = u(k)/(1.0+u(k))
!       Recurrence coefficients are slightly differend from those used in regular G-R quadrature
        b = 0.5*(1.0-tt)/(pp%aa+alpha)
        d = (c - cp%rj) + 2*pp%aa*b*(pp%r - c)
        dij = cp%rj - cp%ri

        xyzin(0,0,1,k) = 1.0
        xyzin(0,0,2,k) = 1.0
        xyzin(0,0,3,k) = ww

        xyzin(1,0,1,k) = d(1)
        xyzin(1,0,2,k) = d(2)
        xyzin(1,0,3,k) = d(3)*ww

        ! VRR (Lj+1,0) <- Rpj*(Lj,0) + Lj*b*(Lj-1,0)
        DO nj = 2, (iang+jang-2)
            xyzin(nj,0,:,k) = d(:)*xyzin(nj-1,0,:,k) + (nj-1)*b*xyzin(nj-2,0,:,k)
        END DO

        ! HRR (Lj,Li+1) <- (Lj+1,Li) + Rij*(Lj,Li)
        nj = (iang+jang-2)
        DO ni = 1, (iang-1)
            nj = nj-1
            xyzin(0:nj,ni,1,k) = xyzin(1:nj+1,ni-1,1,k) + dij(1)*xyzin(0:nj,ni-1,1,k)
            xyzin(0:nj,ni,2,k) = xyzin(1:nj+1,ni-1,2,k) + dij(2)*xyzin(0:nj,ni-1,2,k)
            xyzin(0:nj,ni,3,k) = xyzin(1:nj+1,ni-1,3,k) + dij(3)*xyzin(0:nj,ni-1,3,k)
        END DO

    END DO
    END ASSOCIATE

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Compute 1D integrals needed in calculation of the  Hellmann-Feynman
!>  contribution to the gradient
!> @details They differ from the regular integrals
!>  only by the \f$ 2u^2 \f$ factor. Note, that 2*(ai+aj) factor is absent
!>  here - it will be applied to the final gradient contribution
!  TODO:
!  Redesign Gauss-Rys quadrature code to handle both cases
!> @note The common factor for the integral block is \f$ 2\Pi \f$
!> @param[in]  cp       shell pair data
!> @param[in]  id       current pair of primitives
!> @param[in]  c        coordinates of the charged particle
!> @param[in]  znuc     charge of the particle
!> @param[out] xyzin    array of 1D integrals
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE DQGaussRys(cp, id, c, znuc, xyzin)
!dir$ attributes forceinline :: DQGaussRys
    TYPE(shpair_t), INTENT(IN) :: cp
    INTEGER, INTENT(IN) :: id
    REAL(KIND=fp), INTENT(IN)   :: c(3), znuc
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT)  :: xyzin(0:,0:,:,:)

    COMMON /ROOT  / xx,u(13),w(13),nroots
      REAL(KIND=fp) :: xx,u,w
      INTEGER :: nroots
!$omp threadprivate(/ROOT  /)

    INTEGER :: ni, nj, k
    REAL(KIND=fp) :: ww, tt
    REAL(KIND=fp) :: b, d(3), dij(3)
!dir$ assume_aligned xyzin : 64

    SELECT CASE (nroots)
        CASE (:3) ; CALL rt123
        CASE (4)  ; CALL root4
        CASE (5)  ; CALL root5
        CASE (6:) ; CALL root6
    END SELECT

    ASSOCIATE (pp => cp%p(id), iang => cp%iang, jang => cp%jang)

    dij = cp%rj - cp%ri

    DO k = 1, nroots
        ww = w(k)*znuc*u(k)
        tt = u(k)/(1.0+u(k))
        b = 0.5*(1.0-tt)/pp%aa

        d = (pp%r-cp%rj) - tt*(pp%r-c)

        xyzin(0,0,1,k) = 1.0
        xyzin(0,0,2,k) = 1.0
        xyzin(0,0,3,k) = ww

        xyzin(1,0,1,k) = d(1)
        xyzin(1,0,2,k) = d(2)
        xyzin(1,0,3,k) = d(3)*ww

        ! VRR (Lj+1,0) <- Rpj*(Lj,0) + Lj*b*(Lj-1,0)
        DO nj = 2, (iang+jang-2)+1
            xyzin(nj,0,:,k) = d(:)*xyzin(nj-1,0,:,k) + (nj-1)*b*xyzin(nj-2,0,:,k)
        END DO

        ! HRR (Lj,Li+1) <- (Lj+1,Li) + Rij*(Lj,Li)
        nj = (iang+jang-2)+1
        DO ni = 1, (iang-1)+1
            nj = nj-1
            xyzin(0:nj,ni,1,k) = xyzin(1:nj+1,ni-1,1,k) + dij(1)*xyzin(0:nj,ni-1,1,k)
            xyzin(0:nj,ni,2,k) = xyzin(1:nj+1,ni-1,2,k) + dij(2)*xyzin(0:nj,ni-1,2,k)
            xyzin(0:nj,ni,3,k) = xyzin(1:nj+1,ni-1,3,k) + dij(3)*xyzin(0:nj,ni-1,3,k)
        END DO

    END DO
    END ASSOCIATE

 END SUBROUTINE

!!--------------------------------------------------------------------------------
!
!!> @brief Compute 1D integrals for 1e Coulomb integrals.
!!> @details In this implementation 1D integrals at Rys abscissae are
!!>  computed using Gauss-Hermite quadrature. This subroutine uses
!!>  less CPU cache, but is also slightly slower, than its recurrence-based
!!>  counterpart. This is how 1D Coulomb integrals are computed in original GAMESS.
!!> @note The common factor for the integral block is \f$ 2\Pi^{-1/2} \f$
!!> @param[in]  shi      first shell data
!!> @param[in]  shj      second shell data
!!> @param[in]  aa       total exponent (sum of primitive exponents)
!!> @param[in]  ax       `X` coordinate of shell pair center
!!> @param[in]  ay       `Y` coordinate of shell pair center
!!> @param[in]  az       `Z` coordinate of shell pair center
!!> @param[in]  cx       `X` coordinate of the charged particle
!!> @param[in]  cy       `Y` coordinate of the charged particle
!!> @param[in]  cz       `Z` coordinate of the charged particle
!!> @param[in]  znuc     charge of the particle
!!> @param[out] xyzin    array of 1D integrals, dims=(Lmax=6+1,Lmax=6+1,XYZ=3,MaxRoots=7)
!!> @author   Vladimir Mironov
!!
!!> @note It was left here to be able to easily reconstruct GR+GH subroutines if needed
!!
!!     REVISION HISTORY:
!!> @date _Sep, 2018_ Initial release
!!
! SUBROUTINE QGaussRys_old(shi, shj, aa, ax, ay, az, cx, cy, cz, znuc, xyzin)
!!dir$ attributes inline :: QGaussRys_old
!    TYPE(shell_t), INTENT(IN) :: shi, shj
!    REAL(KIND=fp), INTENT(IN)   :: aa, ax, ay, az, cx, cy, cz, znuc
!    REAL(KIND=fp), INTENT(OUT)  :: xyzin(:,:,:,:)
!
!    COMMON /ROOT  / xx,u(13),w(13),nroots
!      REAL(KIND=fp) :: xx,u,w
!      INTEGER :: nroots
!!$omp threadprivate(/ROOT  /)
!
!    INTEGER :: &
!        ni, nj, k, j0
!
!    REAL(KIND=fp) :: &
!        uu, ww, tt, taa, x0, y0, z0, xint, yint, zint
!
!    SELECT CASE (nroots)
!        CASE (:3) ; CALL rt123
!        CASE (4)  ; CALL root4
!        CASE (5)  ; CALL root5
!        CASE (6:) ; CALL root6
!    END SELECT
!
!    DO k = 1, nroots
!        uu = aa*u(k)
!        ww = w(k)*znuc
!        tt = 1/(aa+uu)
!        taa = sqrt(tt)
!        x0 = (aa*ax+uu*cx)*tt
!        y0 = (aa*ay+uu*cy)*tt
!        z0 = (aa*az+uu*cz)*tt
!
!        j0 = 2
!
!!       J0 skips the trivial combination NI==NJ==1
!!       that is done explicitly now
!        xyzin(1,1,1,k) = SQRTPI
!        xyzin(1,1,2,k) = SQRTPI
!        xyzin(1,1,3,k) = SQRTPI*ww
!        DO ni = 1, shi%ang
!            DO nj = j0, shj%ang
!                CALL doQuadGaussHermite(xint, yint, zint, taa, &
!                    x0, y0, z0, &
!                    shi%x, shi%y, shi%z, &
!                    shj%x, shj%y, shj%z, ni, nj)
!                xyzin(nj,ni,1,k) = xint
!                xyzin(nj,ni,2,k) = yint
!                xyzin(nj,ni,3,k) = zint*ww
!            END DO
!            j0 = 1
!        END DO
!    END DO
!
! END SUBROUTINE

!--------------------------------------------------------------------------------
!       GENERAL SUPPLEMENTARY ROUTINES
!--------------------------------------------------------------------------------


!> @brief Add contribution of the 1e-inegral block to the triangular matrix
!> @param[in]       shi     first shell data
!> @param[in]       shj     second shell data
!> @param[in]       mblk    square block of 1e integrals passed as 1D array
!> @param[inout]    m       packed triangular matrix of 1e integral contribution
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE update_triang_matrix(shi, shj, mblk, m)
    TYPE(shell_t), INTENT(IN) :: shi, shj
    REAL(KIND=fp), CONTIGUOUS, INTENT(INOUT) :: m(:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN) :: mblk(:)

    INTEGER :: i, j, nn, li, lj, mj, mi, jmax
    LOGICAL :: iandj
!dir$ assume_aligned mblk : 64

    iandj = shi%shid==shj%shid

    jmax = shj%nao-1
    nn = 0
    DO i = 0, shi%nao-1
        li = shi%locao+i
        mi = (li*(li-1))/2
        IF (iandj) jmax = i
        DO j = 0, jmax
            lj = shj%locao+j
            mj = lj+mi
            nn = nn+1
            m(mj) = mblk(nn)
        END DO
    END DO
 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Copy density block from the triangular density matrix
!> @details This subroutine assumes arbitrary order of shell IDs
!> @param[in]       shi     first shell data
!> @param[in]       shj     second shell data
!> @param[in]       dij     density matrix in packed triangular form
!> @param[out]      denab   density matrix block for shells shi and shj
!> @note Used in TVDER-based subroutines
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE density_unordered(shi, shj, dij, denab)
    TYPE(shell_t), INTENT(IN) :: shi, shj
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN) :: denab(:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT) :: dij(:)

    INTEGER :: ij, i, j, nn, i0, j0

    ij = 0
    DO i = 0, shi%nao-1
        DO j = 0, shj%nao-1

            ij = ij+1
            i0 = max(shi%locao+i,shj%locao+j)
            j0 = min(shi%locao+i,shj%locao+j)
            nn = (i0-1)*i0/2 + j0
            dij(ij) = 2*denab(nn)
        END DO
    END DO

 END SUBROUTINE

!--------------------------------------------------------------------------------

!> @brief Copy density block from the triangular density matrix
!> @details This subroutine assumes `shi%shid>=shj%shid`
!> @param[in]       shi     first shell data
!> @param[in]       shj     second shell data
!> @param[in]       dij     density matrix in packed triangular form
!> @param[out]      denab   density matrix block for shells shi and shj
!> @note Used in HELFEY-based subroutines
!
!> @author   Vladimir Mironov
!
!     REVISION HISTORY:
!> @date _Sep, 2018_ Initial release
!
 SUBROUTINE density_ordered(shi, shj, dij, denab)
    TYPE(shell_t), INTENT(IN) :: shi, shj
    REAL(KIND=fp), CONTIGUOUS, INTENT(IN) :: denab(:)
    REAL(KIND=fp), CONTIGUOUS, INTENT(OUT) :: dij(:)

    INTEGER :: ij, i, j, nn, jmax, i0, j0
    REAL(KIND=fp) :: den
    LOGICAL :: iandj

    iandj = shi%shid == shj%shid

    jmax = shj%nao-1

    ij = 0
    DO i = 0, shi%nao-1

        IF (iandj) jmax = i
        DO j = 0, jmax
            ij = ij+1
            i0 = shi%locao+i
            j0 = shj%locao+j
            nn = (i0-1)*i0/2 + j0

            den = denab(nn)
            IF (.NOT.iandj.OR.i/=j) den = 2*den
            dij(ij) = den

        END DO
    END DO
 END SUBROUTINE

END MODULE
